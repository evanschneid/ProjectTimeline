import { openBlock as p, createElementBlock as P, createElementVNode as ee, reactive as $t, computed as Y, unref as s, ref as W, watch as ft, onMounted as Fe, nextTick as Dt, toRef as an, defineComponent as Ue, renderSlot as H, createCommentVNode as _, normalizeClass as ve, withKeys as ie, createBlock as de, withModifiers as Ge, normalizeStyle as ut, normalizeProps as Ye, mergeProps as Ae, Fragment as ce, createTextVNode as We, toDisplayString as Se, renderList as De, createVNode as qe, Transition as mt, withCtx as se, onBeforeUpdate as qn, onUnmounted as sn, withDirectives as St, vShow as Ct, createSlots as Be, isRef as nt, guardReactiveProps as Ze, resolveDynamicComponent as Pt, useSlots as un, getCurrentScope as Jn, onScopeDispose as Qn, Teleport as ea } from "vue";
import { isBefore as cn, isEqual as Yn, isAfter as dn, setHours as Vn, setMinutes as Ln, setSeconds as En, setMilliseconds as fn, parse as rn, isValid as Nt, isDate as ta, format as kt, getMonth as he, getDay as na, getYear as ge, getHours as Ke, getMinutes as xe, getSeconds as dt, parseISO as aa, startOfWeek as pn, endOfWeek as ra, setMonth as Rt, setYear as lt, addDays as ct, set as Re, add as Fn, addMonths as at, subMonths as wt, getISOWeek as la, differenceInCalendarDays as oa, eachDayOfInterval as kn, addYears as sa, subYears as ia, sub as ua } from "date-fns";
const ot = (e, n) => {
  const a = e.__vccOpts || e;
  for (const [t, l] of n)
    a[t] = l;
  return a;
}, ca = {}, da = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, fa = /* @__PURE__ */ ee("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1), ma = /* @__PURE__ */ ee("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), va = /* @__PURE__ */ ee("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), ya = /* @__PURE__ */ ee("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1), ha = [
  fa,
  ma,
  va,
  ya
];
function ga(e, n) {
  return p(), P("svg", da, ha);
}
const Et = /* @__PURE__ */ ot(ca, [["render", ga]]), pa = {}, ka = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, wa = /* @__PURE__ */ ee("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1), ba = /* @__PURE__ */ ee("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), $a = [
  wa,
  ba
];
function Da(e, n) {
  return p(), P("svg", ka, $a);
}
const Ma = /* @__PURE__ */ ot(pa, [["render", Da]]), _a = {}, Ta = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Aa = /* @__PURE__ */ ee("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), Sa = [
  Aa
];
function Ca(e, n) {
  return p(), P("svg", Ta, Sa);
}
const wn = /* @__PURE__ */ ot(_a, [["render", Ca]]), Pa = {}, Na = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Ra = /* @__PURE__ */ ee("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1), Ia = [
  Ra
];
function Oa(e, n) {
  return p(), P("svg", Na, Ia);
}
const bn = /* @__PURE__ */ ot(Pa, [["render", Oa]]), Ba = {}, Ya = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Va = /* @__PURE__ */ ee("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1), La = /* @__PURE__ */ ee("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), Ea = [
  Va,
  La
];
function Fa(e, n) {
  return p(), P("svg", Ya, Ea);
}
const Un = /* @__PURE__ */ ot(Ba, [["render", Fa]]), Ua = {}, Ha = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Wa = /* @__PURE__ */ ee("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), za = [
  Wa
];
function ja(e, n) {
  return p(), P("svg", Ha, za);
}
const Hn = /* @__PURE__ */ ot(Ua, [["render", ja]]), Ka = {}, xa = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Ga = /* @__PURE__ */ ee("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), Za = [
  Ga
];
function Xa(e, n) {
  return p(), P("svg", xa, Za);
}
const Wn = /* @__PURE__ */ ot(Ka, [["render", Xa]]), $n = (e, n) => {
  const a = rn(e, n.slice(0, e.length), new Date());
  return Nt(a) && ta(a) ? a : null;
}, qa = (e, n) => {
  if (typeof n == "string")
    return $n(e, n);
  if (Array.isArray(n)) {
    let a = null;
    for (const t of n)
      if (a = $n(e, t), a)
        break;
    return a;
  }
  return typeof n == "function" ? n(e) : null;
}, w = (e) => e ? new Date(e) : new Date(), Ja = (e, n) => {
  if (n) {
    const t = (e.getMonth() + 1).toString().padStart(2, "0"), l = e.getDate().toString().padStart(2, "0"), c = e.getHours().toString().padStart(2, "0"), k = e.getMinutes().toString().padStart(2, "0");
    return `${e.getFullYear()}-${t}-${l}T${c}:${k}:00.000Z`;
  }
  const a = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(a).toISOString();
}, ze = (e) => {
  let n = w(JSON.parse(JSON.stringify(e)));
  return n = Vn(n, 0), n = Ln(n, 0), n = En(n, 0), n = fn(n, 0), n;
}, Le = (e, n, a, t) => {
  let l = e ? w(e) : w();
  return (n || n === 0) && (l = Vn(l, +n)), (a || a === 0) && (l = Ln(l, +a)), (t || t === 0) && (l = En(l, +t)), fn(l, 0);
}, Pe = (e, n) => !e || !n ? !1 : cn(ze(e), ze(n)), pe = (e, n) => !e || !n ? !1 : Yn(ze(e), ze(n)), Oe = (e, n) => !e || !n ? !1 : dn(ze(e), ze(n)), zn = (e, n, a) => e && e[0] && e[1] ? Oe(a, e[0]) && Pe(a, e[1]) : e && e[0] && n ? Oe(a, e[0]) && Pe(a, n) || Pe(a, e[0]) && Oe(a, n) : !1, pt = $t({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), jn = () => {
  const e = (t) => {
    pt.menuFocused = t;
  }, n = (t) => {
    pt.shiftKeyInMenu !== t && (pt.shiftKeyInMenu = t);
  };
  return {
    control: Y(() => ({ shiftKeyInMenu: pt.shiftKeyInMenu, menuFocused: pt.menuFocused })),
    setMenuFocused: e,
    setShiftKey: n
  };
};
function mn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ot = {}, Qa = {
  get exports() {
    return Ot;
  },
  set exports(e) {
    Ot = e;
  }
};
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    if (t === null || t === !0 || t === !1)
      return NaN;
    var l = Number(t);
    return isNaN(l) ? l : l < 0 ? Math.ceil(l) : Math.floor(l);
  }
  e.exports = n.default;
})(Qa, Ot);
const er = /* @__PURE__ */ mn(Ot);
var Bt = {}, tr = {
  get exports() {
    return Bt;
  },
  set exports(e) {
    Bt = e;
  }
};
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    var l = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return l.setUTCFullYear(t.getFullYear()), t.getTime() - l.getTime();
  }
  e.exports = n.default;
})(tr, Bt);
const Dn = /* @__PURE__ */ mn(Bt);
function nr(e, n) {
  var a = or(n);
  return a.formatToParts ? rr(a, e) : lr(a, e);
}
var ar = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function rr(e, n) {
  try {
    for (var a = e.formatToParts(n), t = [], l = 0; l < a.length; l++) {
      var c = ar[a[l].type];
      c >= 0 && (t[c] = parseInt(a[l].value, 10));
    }
    return t;
  } catch (k) {
    if (k instanceof RangeError)
      return [NaN];
    throw k;
  }
}
function lr(e, n) {
  var a = e.format(n).replace(/\u200E/g, ""), t = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(a);
  return [t[3], t[1], t[2], t[4], t[5], t[6]];
}
var xt = {};
function or(e) {
  if (!xt[e]) {
    var n = new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: "America/New_York",
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(new Date("2014-06-25T04:00:00.123Z")), a = n === "06/25/2014, 00:00:00" || n === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    xt[e] = a ? new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return xt[e];
}
function vn(e, n, a, t, l, c, k) {
  var M = new Date(0);
  return M.setUTCFullYear(e, n, a), M.setUTCHours(t, l, c, k), M;
}
var Mn = 36e5, sr = 6e4, Gt = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function yn(e, n, a) {
  var t, l;
  if (!e || (t = Gt.timezoneZ.exec(e), t))
    return 0;
  var c;
  if (t = Gt.timezoneHH.exec(e), t)
    return c = parseInt(t[1], 10), _n(c) ? -(c * Mn) : NaN;
  if (t = Gt.timezoneHHMM.exec(e), t) {
    c = parseInt(t[1], 10);
    var k = parseInt(t[2], 10);
    return _n(c, k) ? (l = Math.abs(c) * Mn + k * sr, c > 0 ? -l : l) : NaN;
  }
  if (cr(e)) {
    n = new Date(n || Date.now());
    var M = a ? n : ir(n), O = ln(M, e), I = a ? O : ur(n, O, e);
    return -I;
  }
  return NaN;
}
function ir(e) {
  return vn(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  );
}
function ln(e, n) {
  var a = nr(e, n), t = vn(
    a[0],
    a[1] - 1,
    a[2],
    a[3] % 24,
    a[4],
    a[5],
    0
  ).getTime(), l = e.getTime(), c = l % 1e3;
  return l -= c >= 0 ? c : 1e3 + c, t - l;
}
function ur(e, n, a) {
  var t = e.getTime(), l = t - n, c = ln(new Date(l), a);
  if (n === c)
    return n;
  l -= c - n;
  var k = ln(new Date(l), a);
  return c === k ? c : Math.max(c, k);
}
function _n(e, n) {
  return -23 <= e && e <= 23 && (n == null || 0 <= n && n <= 59);
}
var Tn = {};
function cr(e) {
  if (Tn[e])
    return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e }), Tn[e] = !0, !0;
  } catch {
    return !1;
  }
}
var Kn = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, Zt = 36e5, An = 6e4, dr = 2, Ie = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    /^([+-]\d{3})$/,
    /^([+-]\d{4})$/
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    /^([+-]\d{5})/,
    /^([+-]\d{6})/
  ],
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  timeZone: Kn
};
function on(e, n) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (e === null)
    return new Date(NaN);
  var a = n || {}, t = a.additionalDigits == null ? dr : er(a.additionalDigits);
  if (t !== 2 && t !== 1 && t !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
    return new Date(e.getTime());
  if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
    return new Date(e);
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return new Date(NaN);
  var l = fr(e), c = mr(l.date, t), k = c.year, M = c.restDateString, O = vr(M, k);
  if (isNaN(O))
    return new Date(NaN);
  if (O) {
    var I = O.getTime(), F = 0, C;
    if (l.time && (F = yr(l.time), isNaN(F)))
      return new Date(NaN);
    if (l.timeZone || a.timeZone) {
      if (C = yn(l.timeZone || a.timeZone, new Date(I + F)), isNaN(C))
        return new Date(NaN);
    } else
      C = Dn(new Date(I + F)), C = Dn(new Date(I + F + C));
    return new Date(I + F + C);
  } else
    return new Date(NaN);
}
function fr(e) {
  var n = {}, a = Ie.dateTimePattern.exec(e), t;
  if (a ? (n.date = a[1], t = a[3]) : (a = Ie.datePattern.exec(e), a ? (n.date = a[1], t = a[2]) : (n.date = null, t = e)), t) {
    var l = Ie.timeZone.exec(t);
    l ? (n.time = t.replace(l[1], ""), n.timeZone = l[1].trim()) : n.time = t;
  }
  return n;
}
function mr(e, n) {
  var a = Ie.YYY[n], t = Ie.YYYYY[n], l;
  if (l = Ie.YYYY.exec(e) || t.exec(e), l) {
    var c = l[1];
    return {
      year: parseInt(c, 10),
      restDateString: e.slice(c.length)
    };
  }
  if (l = Ie.YY.exec(e) || a.exec(e), l) {
    var k = l[1];
    return {
      year: parseInt(k, 10) * 100,
      restDateString: e.slice(k.length)
    };
  }
  return {
    year: null
  };
}
function vr(e, n) {
  if (n === null)
    return null;
  var a, t, l, c;
  if (e.length === 0)
    return t = new Date(0), t.setUTCFullYear(n), t;
  if (a = Ie.MM.exec(e), a)
    return t = new Date(0), l = parseInt(a[1], 10) - 1, Cn(n, l) ? (t.setUTCFullYear(n, l), t) : new Date(NaN);
  if (a = Ie.DDD.exec(e), a) {
    t = new Date(0);
    var k = parseInt(a[1], 10);
    return pr(n, k) ? (t.setUTCFullYear(n, 0, k), t) : new Date(NaN);
  }
  if (a = Ie.MMDD.exec(e), a) {
    t = new Date(0), l = parseInt(a[1], 10) - 1;
    var M = parseInt(a[2], 10);
    return Cn(n, l, M) ? (t.setUTCFullYear(n, l, M), t) : new Date(NaN);
  }
  if (a = Ie.Www.exec(e), a)
    return c = parseInt(a[1], 10) - 1, Pn(n, c) ? Sn(n, c) : new Date(NaN);
  if (a = Ie.WwwD.exec(e), a) {
    c = parseInt(a[1], 10) - 1;
    var O = parseInt(a[2], 10) - 1;
    return Pn(n, c, O) ? Sn(n, c, O) : new Date(NaN);
  }
  return null;
}
function yr(e) {
  var n, a, t;
  if (n = Ie.HH.exec(e), n)
    return a = parseFloat(n[1].replace(",", ".")), Xt(a) ? a % 24 * Zt : NaN;
  if (n = Ie.HHMM.exec(e), n)
    return a = parseInt(n[1], 10), t = parseFloat(n[2].replace(",", ".")), Xt(a, t) ? a % 24 * Zt + t * An : NaN;
  if (n = Ie.HHMMSS.exec(e), n) {
    a = parseInt(n[1], 10), t = parseInt(n[2], 10);
    var l = parseFloat(n[3].replace(",", "."));
    return Xt(a, t, l) ? a % 24 * Zt + t * An + l * 1e3 : NaN;
  }
  return null;
}
function Sn(e, n, a) {
  n = n || 0, a = a || 0;
  var t = new Date(0);
  t.setUTCFullYear(e, 0, 4);
  var l = t.getUTCDay() || 7, c = n * 7 + a + 1 - l;
  return t.setUTCDate(t.getUTCDate() + c), t;
}
var hr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], gr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function xn(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function Cn(e, n, a) {
  if (n < 0 || n > 11)
    return !1;
  if (a != null) {
    if (a < 1)
      return !1;
    var t = xn(e);
    if (t && a > gr[n] || !t && a > hr[n])
      return !1;
  }
  return !0;
}
function pr(e, n) {
  if (n < 1)
    return !1;
  var a = xn(e);
  return !(a && n > 366 || !a && n > 365);
}
function Pn(e, n, a) {
  return !(n < 0 || n > 52 || a != null && (a < 0 || a > 6));
}
function Xt(e, n, a) {
  return !(e != null && (e < 0 || e >= 25) || n != null && (n < 0 || n >= 60) || a != null && (a < 0 || a >= 60));
}
var Yt = {}, kr = {
  get exports() {
    return Yt;
  },
  set exports(e) {
    Yt = e;
  }
}, Vt = {}, wr = {
  get exports() {
    return Vt;
  },
  set exports(e) {
    Vt = e;
  }
};
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t, l) {
    if (t == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var c in l)
      Object.prototype.hasOwnProperty.call(l, c) && (t[c] = l[c]);
    return t;
  }
  e.exports = n.default;
})(wr, Vt);
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = l;
  var a = t(Vt);
  function t(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function l(c) {
    return (0, a.default)({}, c);
  }
  e.exports = n.default;
})(kr, Yt);
const br = /* @__PURE__ */ mn(Yt);
function $r(e, n, a) {
  var t = on(e, a), l = yn(n, t, !0), c = new Date(t.getTime() - l), k = new Date(0);
  return k.setFullYear(c.getUTCFullYear(), c.getUTCMonth(), c.getUTCDate()), k.setHours(c.getUTCHours(), c.getUTCMinutes(), c.getUTCSeconds(), c.getUTCMilliseconds()), k;
}
function Dr(e, n, a) {
  if (typeof e == "string" && !e.match(Kn)) {
    var t = br(a);
    return t.timeZone = n, on(e, t);
  }
  var l = on(e, a), c = vn(
    l.getFullYear(),
    l.getMonth(),
    l.getDate(),
    l.getHours(),
    l.getMinutes(),
    l.getSeconds(),
    l.getMilliseconds()
  ).getTime(), k = yn(n, new Date(c));
  return new Date(c + k);
}
const Mr = (e, n = 3) => {
  const a = [];
  for (let t = 0; t < e.length; t += n)
    a.push([e[t], e[t + 1], e[t + 2]]);
  return a;
}, _r = (e, n) => {
  const a = [1, 2, 3, 4, 5, 6, 7].map((c) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${c}T00:00:00+00:00`)).slice(0, 2)), t = a.slice(0, n), l = a.slice(n + 1, a.length);
  return [a[n]].concat(...l).concat(...t);
}, Tr = (e) => {
  const n = [];
  for (let a = +e[0]; a <= +e[1]; a++)
    n.push({ value: +a, text: `${a}` });
  return n;
}, Ar = (e, n) => {
  const a = new Intl.DateTimeFormat(e, { month: n, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((l) => {
    const c = l < 10 ? `0${l}` : l;
    return new Date(`2017-${c}-01T00:00:00+00:00`);
  }).map((l, c) => ({
    text: a.format(l),
    value: c
  }));
}, Sr = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Ce = (e) => {
  const n = s(e);
  return n != null && n.$el ? n == null ? void 0 : n.$el : n;
}, Cr = (e) => Object.assign({ type: "dot" }, e), Gn = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, Lt = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Me = (e) => e, Nn = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, Rn = (e) => Object.assign(
  {
    menuAppear: "dp-menu-appear",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down"
  },
  e
), Pr = (e) => Object.assign(
  {
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (n) => `Increment ${n}`,
    decrementValue: (n) => `Decrement ${n}`,
    openTpOverlay: (n) => `Open ${n} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month",
    day: () => ""
  },
  e
), Nr = (e) => e === null ? 0 : typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2, Rr = (e, n, a) => e || (typeof a == "string" ? a : n), Ir = (e) => typeof e == "boolean" ? e ? Rn({}) : !1 : Rn(e), Or = () => ({
  enterSubmit: !0,
  tabSubmit: !0,
  openMenu: !0,
  rangeSeparator: " - "
}), Br = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e), Ve = (e) => {
  const n = () => {
    if (e.partialRange)
      return null;
    throw new Error(Lt.prop("partial-range"));
  }, a = Y(() => ({
    ariaLabels: Pr(e.ariaLabels),
    textInputOptions: Object.assign(Or(), e.textInputOptions),
    multiCalendars: Nr(e.multiCalendars),
    previewFormat: Rr(e.previewFormat, e.format, c()),
    filters: Br(e.filters),
    transitions: Ir(e.transitions),
    startTime: u()
  })), t = (r) => {
    if (e.range)
      return r();
    throw new Error(Lt.prop("range"));
  }, l = () => {
    const r = e.enableSeconds ? ":ss" : "";
    return e.is24 ? `HH:mm${r}` : `hh:mm${r} aa`;
  }, c = () => e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? l() : e.weekPicker ? "MM/dd/yyyy" : e.yearPicker ? "yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${l()}` : "MM/dd/yyyy", k = (r, m) => {
    if (typeof e.format == "function")
      return e.format(r);
    const h = m || c(), $ = e.formatLocale ? { locale: e.formatLocale } : void 0;
    return Array.isArray(r) ? `${kt(r[0], h, $)} ${e.modelAuto && !r[1] ? "" : a.value.textInputOptions.rangeSeparator || "-"} ${r[1] ? kt(r[1], h, $) : ""}` : kt(r, h, $);
  }, M = (r) => e.timezone ? $r(r, e.timezone) : r, O = (r) => e.timezone ? Dr(r, e.timezone) : r, I = Y(() => (r) => {
    var m;
    return (m = e.hideNavigation) == null ? void 0 : m.includes(r);
  }), F = (r) => {
    const m = e.maxDate ? Oe(M(r), M(w(e.maxDate))) : !1, h = e.minDate ? Pe(M(r), M(w(e.minDate))) : !1, $ = B(r, e.disabledDates), re = a.value.filters.months.map(($e) => +$e).includes(he(r)), v = e.disabledWeekDays.length ? e.disabledWeekDays.some(($e) => +$e === na(r)) : !1, i = e.allowedDates.length ? !e.allowedDates.some(($e) => pe(M(w($e)), M(r))) : !1, S = ge(r), fe = S < +e.yearRange[0] || S > +e.yearRange[1];
    return !(m || h || $ || re || fe || v || i);
  }, C = (r) => {
    const m = {
      hours: Ke(w()),
      minutes: xe(w()),
      seconds: dt(w())
    };
    return Object.assign(m, r);
  }, u = () => e.range ? e.startTime && Array.isArray(e.startTime) ? [C(e.startTime[0]), C(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? C(e.startTime) : null, T = (r) => !F(r), U = (r) => Array.isArray(r) ? Nt(r[0]) && (r[1] ? Nt(r[1]) : !0) : r ? Nt(r) : !1, V = (r) => r instanceof Date ? r : aa(r), J = (r) => {
    const m = pn(M(r), { weekStartsOn: +e.weekStart }), h = ra(M(r), { weekStartsOn: +e.weekStart });
    return [m, h];
  }, B = (r, m) => Array.isArray(m) ? m.some((h) => pe(M(w(h)), M(r))) : m(r), E = (r, m, h) => {
    let $ = r ? w(r) : w();
    return (m || m === 0) && ($ = Rt($, m)), h && ($ = lt($, h)), $;
  }, N = (r) => Re(w(), { hours: Ke(r), minutes: xe(r), seconds: dt(r) }), K = (r) => Re(w(), {
    hours: +r.hours || 0,
    minutes: +r.minutes || 0,
    seconds: +r.seconds || 0
  }), te = (r, m, h, $) => {
    if (!r)
      return !0;
    if ($) {
      const X = h === "max" ? cn(r, m) : dn(r, m), re = { seconds: 0, milliseconds: 0 };
      return X || Yn(Re(r, re), Re(m, re));
    }
    return h === "max" ? r.getTime() <= m.getTime() : r.getTime() >= m.getTime();
  }, le = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, f = (r) => Array.isArray(r) ? [r[0] ? N(r[0]) : null, r[1] ? N(r[1]) : null] : N(r), D = (r) => {
    const m = e.maxTime ? K(e.maxTime) : w(e.maxDate);
    return Array.isArray(r) ? te(r[0], m, "max", !!e.maxDate) && te(r[1], m, "max", !!e.maxDate) : te(r, m, "max", !!e.maxDate);
  }, L = (r, m) => {
    const h = e.minTime ? K(e.minTime) : w(e.minDate);
    return Array.isArray(r) ? te(r[0], h, "min", !!e.minDate) && te(r[1], h, "min", !!e.minDate) && m : te(r, h, "min", !!e.minDate) && m;
  }, x = (r) => {
    let m = !0;
    if (!r || le())
      return !0;
    const h = !e.minDate && !e.maxDate ? f(r) : r;
    return (e.maxTime || e.maxDate) && (m = D(Me(h))), (e.minTime || e.minDate) && (m = L(Me(h), m)), m;
  }, R = (r, m) => {
    const h = w(JSON.parse(JSON.stringify(r))), $ = [];
    for (let X = 0; X < 7; X++) {
      const re = ct(h, X), v = he(re) !== m;
      $.push({
        text: e.hideOffsetDates && v ? "" : re.getDate(),
        value: re,
        current: !v,
        classData: {}
      });
    }
    return $;
  }, Z = (r, m) => {
    const h = [], $ = w(M(new Date(m, r))), X = w(M(new Date(m, r + 1, 0))), re = pn($, { weekStartsOn: e.weekStart }), v = (i) => {
      const S = R(i, r);
      if (h.push({ days: S }), !h[h.length - 1].days.some(
        (fe) => pe(ze(fe.value), ze(X))
      )) {
        const fe = ct(i, 7);
        v(fe);
      }
    };
    if (v(re), e.sixWeeks && h.length < 6) {
      const i = 6 - h.length;
      for (let S = 1; S <= i; S++) {
        const fe = h[h.length - 1], $e = fe.days[fe.days.length - 1], be = R(ct($e.value, 1), he($));
        h.push({ days: be });
      }
    }
    return h;
  }, ne = (r, m, h) => [Re(w(r), { date: 1 }), Re(w(), { month: m, year: h, date: 1 })], A = (r, m) => Pe(...ne(e.minDate, r, m)) || pe(...ne(e.minDate, r, m)), g = (r, m) => Oe(...ne(e.maxDate, r, m)) || pe(...ne(e.maxDate, r, m)), z = (r, m, h) => {
    let $ = !1;
    return e.maxDate && h && g(r, m) && ($ = !0), e.minDate && !h && A(r, m) && ($ = !0), $;
  };
  return {
    checkPartialRangeValue: n,
    checkRangeEnabled: t,
    getZonedDate: M,
    getZonedToUtc: O,
    formatDate: k,
    getDefaultPattern: c,
    validateDate: F,
    getDefaultStartTime: u,
    isDisabled: T,
    isValidDate: U,
    sanitizeDate: V,
    getWeekFromDate: J,
    matchDate: B,
    setDateMonthOrYear: E,
    isValidTime: x,
    getCalendarDays: Z,
    validateMonthYearInRange: (r, m, h, $) => {
      let X = !1;
      return $ ? e.minDate && e.maxDate ? X = z(r, m, h) : (e.minDate && A(r, m) || e.maxDate && g(r, m)) && (X = !0) : X = !0, X;
    },
    validateMaxDate: g,
    validateMinDate: A,
    defaults: a,
    hideNavigationButtons: I
  };
}, ye = $t({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), qt = W(null), At = W(!1), Jt = W(!1), Qt = W(!1), en = W(!1), Ne = W(0), Te = W(0), Je = () => {
  const e = Y(() => At.value ? [...ye.selectionGrid, ye.actionRow].filter((B) => B.length) : Jt.value ? [
    ...ye.timePicker[0],
    ...ye.timePicker[1],
    en.value ? [] : [qt.value],
    ye.actionRow
  ].filter((B) => B.length) : Qt.value ? [...ye.monthPicker, ye.actionRow] : [ye.monthYear, ...ye.calendar, ye.time, ye.actionRow].filter((B) => B.length)), n = (B) => {
    Ne.value = B ? Ne.value + 1 : Ne.value - 1;
    let E = null;
    e.value[Te.value] && (E = e.value[Te.value][Ne.value]), E || (Ne.value = B ? Ne.value - 1 : Ne.value + 1);
  }, a = (B) => {
    if (Te.value === 0 && !B || Te.value === e.value.length && B)
      return;
    Te.value = B ? Te.value + 1 : Te.value - 1, e.value[Te.value] ? e.value[Te.value] && !e.value[Te.value][Ne.value] && Ne.value !== 0 && (Ne.value = e.value[Te.value].length - 1) : Te.value = B ? Te.value - 1 : Te.value + 1;
  }, t = (B) => {
    let E = null;
    e.value[Te.value] && (E = e.value[Te.value][Ne.value]), E ? E.focus({ preventScroll: !At.value }) : Ne.value = B ? Ne.value - 1 : Ne.value + 1;
  }, l = () => {
    n(!0), t(!0);
  }, c = () => {
    n(!1), t(!1);
  }, k = () => {
    a(!1), t(!0);
  }, M = () => {
    a(!0), t(!0);
  }, O = (B, E) => {
    ye[E] = B;
  }, I = (B, E) => {
    ye[E] = B;
  }, F = () => {
    Ne.value = 0, Te.value = 0;
  };
  return {
    buildMatrix: O,
    buildMultiLevelMatrix: I,
    setTimePickerBackRef: (B) => {
      qt.value = B;
    },
    setSelectionGrid: (B) => {
      At.value = B, F(), B || (ye.selectionGrid = []);
    },
    setTimePicker: (B, E = !1) => {
      Jt.value = B, en.value = E, F(), B || (ye.timePicker[0] = [], ye.timePicker[1] = []);
    },
    setTimePickerElements: (B, E = 0) => {
      ye.timePicker[E] = B;
    },
    arrowRight: l,
    arrowLeft: c,
    arrowUp: k,
    arrowDown: M,
    clearArrowNav: () => {
      ye.monthYear = [], ye.calendar = [], ye.time = [], ye.actionRow = [], ye.selectionGrid = [], ye.timePicker[0] = [], ye.timePicker[1] = [], At.value = !1, Jt.value = !1, en.value = !1, Qt.value = !1, F(), qt.value = null;
    },
    setMonthPicker: (B) => {
      Qt.value = B, F();
    },
    refSets: ye
  };
}, In = (e) => Array.isArray(e), tt = (e) => Array.isArray(e), On = (e) => Array.isArray(e) && e.length === 2, Yr = (e, n, a, t, l) => {
  const {
    getDefaultStartTime: c,
    isDisabled: k,
    sanitizeDate: M,
    getWeekFromDate: O,
    setDateMonthOrYear: I,
    validateMonthYearInRange: F,
    defaults: C
  } = Ve(e), u = Y({
    get: () => e.internalModelValue,
    set: (o) => {
      !e.readonly && !e.disabled && n("update:internal-model-value", o);
    }
  }), T = W([]);
  ft(u, () => {
    e.multiCalendars || te();
  });
  const U = W([{ month: he(w()), year: ge(w()) }]), V = $t({
    hours: e.range ? [Ke(w()), Ke(w())] : Ke(w()),
    minutes: e.range ? [xe(w()), xe(w())] : xe(w()),
    seconds: e.range ? [0, 0] : 0
  }), J = Y(
    () => (o) => U.value[o] ? U.value[o].month : 0
  ), B = Y(
    () => (o) => U.value[o] ? U.value[o].year : 0
  ), E = Y(() => e.flow && e.flow.length ? l.value === e.flow.length : !0), N = (o, b, j) => {
    var Q, y;
    U.value[o] || (U.value[o] = { month: 0, year: 0 }), U.value[o].month = b === null ? (Q = U.value[o]) == null ? void 0 : Q.month : b, U.value[o].year = j === null ? (y = U.value[o]) == null ? void 0 : y.year : j;
  }, K = (o, b) => {
    V[o] = b;
  };
  Fe(() => {
    u.value || (e.startDate && (N(0, he(w(e.startDate)), ge(w(e.startDate))), C.value.multiCalendars && yt(0)), C.value.startTime && g()), te(!0);
  });
  const te = (o = !1) => {
    if (u.value)
      return Array.isArray(u.value) ? x(o) : f(u.value);
    if (e.timePicker)
      return R();
    if (e.monthPicker && !e.range)
      return Z();
    if (e.yearPicker && !e.range)
      return ne();
    if (C.value.multiCalendars && o && !e.startDate)
      return le(w(), o);
  }, le = (o, b = !1) => {
    if ((!C.value.multiCalendars || !e.multiStatic || b) && N(0, he(o), ge(o)), C.value.multiCalendars)
      for (let j = 1; j < C.value.multiCalendars; j++) {
        const Q = Re(w(), { month: J.value(j - 1), year: B.value(j - 1) }), y = Fn(Q, { months: 1 });
        U.value[j] = { month: he(y), year: ge(y) };
      }
  }, f = (o) => {
    le(o), K("hours", Ke(o)), K("minutes", xe(o)), K("seconds", dt(o));
  }, D = (o, b) => {
    le(o[0], b);
    const j = (Q, y) => [
      Q(o[0]),
      o[1] ? Q(o[1]) : V[y][1]
    ];
    K("hours", j(Ke, "hours")), K("minutes", j(xe, "minutes")), K("seconds", j(dt, "seconds"));
  }, L = (o, b) => {
    if ((e.range || e.weekPicker) && !e.multiDates)
      return D(o, b);
    if (e.multiDates) {
      const j = o[o.length - 1];
      return f(j);
    }
  }, x = (o) => {
    const b = u.value;
    L(b, o), C.value.multiCalendars && e.multiCalendarsSolo && d();
  }, R = () => {
    if (g(), !e.range)
      u.value = Le(w(), V.hours, V.minutes, A());
    else {
      const o = V.hours, b = V.minutes;
      u.value = [
        Le(w(), o[0], b[0], A()),
        Le(w(), o[1], b[1], A(!1))
      ];
    }
  }, Z = () => {
    u.value = I(w(), J.value(0), B.value(0));
  }, ne = () => {
    u.value = w();
  }, A = (o = !0) => e.enableSeconds ? Array.isArray(V.seconds) ? o ? V.seconds[0] : V.seconds[1] : V.seconds : 0, g = () => {
    const o = c();
    if (o) {
      const b = Array.isArray(o), j = b ? [+o[0].hours, +o[1].hours] : +o.hours, Q = b ? [+o[0].minutes, +o[1].minutes] : +o.minutes, y = b ? [+o[0].seconds, +o[1].seconds] : +o.seconds;
      K("hours", j), K("minutes", Q), e.enableSeconds && K("seconds", y);
    }
  }, z = () => Array.isArray(u.value) && u.value.length ? u.value[u.value.length - 1] : null, d = () => {
    if (Array.isArray(u.value) && u.value.length === 2) {
      const o = w(
        w(u.value[1] ? u.value[1] : at(u.value[0], 1))
      ), [b, j] = [he(u.value[0]), ge(u.value[0])], [Q, y] = [he(u.value[1]), ge(u.value[1])];
      (b !== Q || b === Q && j !== y) && e.multiCalendarsSolo && N(1, he(o), ge(o));
    }
  }, r = (o) => {
    const b = at(o, 1);
    return { month: he(b), year: ge(b) };
  }, m = (o) => {
    const b = he(w(o)), j = ge(w(o));
    if (N(0, b, j), C.value.multiCalendars > 0)
      for (let Q = 1; Q < C.value.multiCalendars; Q++) {
        const y = r(
          Re(w(o), { year: J.value(Q - 1), month: B.value(Q - 1) })
        );
        N(Q, y.month, y.year);
      }
  }, h = (o) => {
    if (u.value && Array.isArray(u.value))
      if (u.value.some((b) => pe(o, b))) {
        const b = u.value.filter((j) => !pe(j, o));
        u.value = b.length ? b : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > u.value.length || !e.multiDatesLimit) && u.value.push(o);
    else
      u.value = [o];
  }, $ = (o, b) => {
    const j = Oe(o, b) ? b : o, Q = Oe(b, o) ? b : o;
    return kn({ start: j, end: Q });
  }, X = (o) => {
    if (Array.isArray(u.value) && u.value[0]) {
      const b = oa(o, u.value[0]), j = $(u.value[0], o), Q = j.length === 1 ? 0 : j.filter((G) => k(G)).length, y = Math.abs(b) - Q;
      if (e.minRange && e.maxRange)
        return y >= +e.minRange && y <= +e.maxRange;
      if (e.minRange)
        return y >= +e.minRange;
      if (e.maxRange)
        return y <= +e.maxRange;
    }
    return !0;
  }, re = (o) => Array.isArray(u.value) && u.value.length === 2 ? e.fixedStart && (Oe(o, u.value[0]) || pe(o, u.value[0])) ? [u.value[0], o] : e.fixedEnd && (Pe(o, u.value[1]) || pe(o, u.value[1])) ? [o, u.value[1]] : u.value : [], v = () => {
    e.autoApply && E.value && n("auto-apply");
  }, i = () => {
    e.autoApply && n("select-date");
  }, S = (o) => !kn({ start: o[0], end: o[1] }).some((j) => k(j)), fe = (o) => (u.value = O(w(o.value)), v()), $e = (o) => {
    const b = Le(w(o.value), V.hours, V.minutes, A());
    e.multiDates ? h(b) : u.value = b, a(), v();
  }, be = () => {
    T.value = u.value ? u.value.slice() : [], T.value.length === 2 && !(e.fixedStart || e.fixedEnd) && (T.value = []);
  }, He = (o, b) => {
    const j = [w(o.value), ct(w(o.value), +e.autoRange)];
    S(j) && (b && m(o.value), T.value = j);
  }, Xe = (o) => {
    T.value = re(w(o.value));
  }, ae = (o) => e.noDisabledRange ? $(T.value[0], o).some((j) => k(j)) : !1, oe = (o, b) => {
    if (be(), e.autoRange)
      return He(o, b);
    if (e.fixedStart || e.fixedEnd)
      return Xe(o);
    T.value[0] ? X(w(o.value)) && !ae(o.value) && (Pe(w(o.value), w(T.value[0])) ? T.value.unshift(w(o.value)) : T.value[1] = w(o.value)) : T.value[0] = w(o.value);
  }, ke = (o) => {
    T.value[o] = Le(
      T.value[o],
      V.hours[o],
      V.minutes[o],
      A(o !== 1)
    );
  }, me = () => {
    T.value.length && (T.value[0] && !T.value[1] ? ke(0) : (ke(0), ke(1), a()), u.value = T.value.slice(), T.value[0] && T.value[1] && e.autoApply && n("auto-apply"), T.value[0] && !T.value[1] && e.modelAuto && e.autoApply && n("auto-apply"));
  }, vt = (o, b = !1) => {
    if (!(k(o.value) || !o.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return fe(o);
      if (!e.range)
        return $e(o);
      tt(V.hours) && tt(V.minutes) && !e.multiDates && (oe(o, b), me());
    }
  }, je = (o) => {
    const b = o.find((j) => j.current);
    return b ? la(b.value) : "";
  }, yt = (o) => {
    for (let b = o - 1; b >= 0; b--) {
      const j = wt(Re(w(), { month: J.value(b + 1), year: B.value(b + 1) }), 1);
      N(b, he(j), ge(j));
    }
    for (let b = o + 1; b <= C.value.multiCalendars - 1; b++) {
      const j = at(Re(w(), { month: J.value(b - 1), year: B.value(b - 1) }), 1);
      N(b, he(j), ge(j));
    }
  }, et = (o) => I(w(), J.value(o), B.value(o)), ht = (o) => Le(o, V.hours, V.minutes, A()), Ut = (o, b) => {
    const j = e.monthPicker ? J.value(o) !== b.month || !b.fromNav : B.value(o) !== b.year;
    if (N(o, b.month, b.year), C.value.multiCalendars && !e.multiCalendarsSolo && yt(o), e.monthPicker || e.yearPicker)
      if (e.range) {
        if (j) {
          let Q = u.value ? u.value.slice() : [];
          Q.length === 2 && Q[1] !== null && (Q = []), Q.length ? Pe(et(o), Q[0]) ? Q.unshift(et(o)) : Q[1] = et(o) : Q = [et(o)], u.value = Q;
        }
      } else
        u.value = et(o);
    n("update-month-year", { instance: o, month: b.month, year: b.year }), t(e.multiCalendarsSolo ? o : void 0);
  }, Ht = async (o = !1) => {
    if (e.autoApply && (e.monthPicker || e.yearPicker)) {
      await Dt();
      const b = e.monthPicker ? o : !1;
      e.range ? n("auto-apply", b || !u.value || u.value.length === 1) : n("auto-apply", b);
    }
    a();
  }, Mt = (o, b) => {
    const j = Re(w(), { month: J.value(b), year: B.value(b) }), Q = o < 0 ? at(j, 1) : wt(j, 1);
    F(he(Q), ge(Q), o < 0, e.preventMinMaxNavigation) && (N(b, he(Q), ge(Q)), C.value.multiCalendars && !e.multiCalendarsSolo && yt(b), n("update-month-year", { instance: b, month: he(Q), year: ge(Q) }), t());
  }, gt = (o) => {
    In(o) && In(u.value) && tt(V.hours) && tt(V.minutes) ? (o[0] && u.value[0] && (u.value[0] = Le(o[0], V.hours[0], V.minutes[0], A())), o[1] && u.value[1] && (u.value[1] = Le(o[1], V.hours[1], V.minutes[1], A(!1)))) : e.multiDates && Array.isArray(u.value) ? u.value[u.value.length - 1] = ht(o) : !e.range && !On(o) && (u.value = ht(o)), n("time-update");
  }, Wt = (o, b = !0, j = !1) => {
    const Q = b ? o : V.hours, y = !b && !j ? o : V.minutes, G = j ? o : V.seconds;
    if (e.range && On(u.value) && tt(Q) && tt(y) && tt(G) && !e.disableTimeRangeValidation) {
      const we = (Ee) => Le(u.value[Ee], Q[Ee], y[Ee], G[Ee]), _e = (Ee) => fn(u.value[Ee], 0);
      if (pe(u.value[0], u.value[1]) && (dn(we(0), _e(1)) || cn(we(1), _e(0))))
        return;
    }
    if (K("hours", Q), K("minutes", y), K("seconds", G), u.value)
      if (e.multiDates) {
        const we = z();
        we && gt(we);
      } else
        gt(u.value);
    else
      e.timePicker && gt(e.range ? [w(), w()] : w());
    a();
  }, zt = (o, b) => {
    e.monthChangeOnScroll && Mt(e.monthChangeOnScroll !== "inverse" ? -o.deltaY : o.deltaY, b);
  }, jt = (o, b, j = !1) => {
    e.monthChangeOnArrows && e.vertical === j && _t(o, b);
  }, _t = (o, b) => {
    Mt(o === "right" ? -1 : 1, b);
  };
  return {
    time: V,
    month: J,
    year: B,
    modelValue: u,
    calendars: U,
    monthYearSelect: Ht,
    isDisabled: k,
    updateTime: Wt,
    getWeekNum: je,
    selectDate: vt,
    updateMonthYear: Ut,
    handleScroll: zt,
    getMarker: (o) => e.markers.find((b) => pe(M(o.value), M(b.date))),
    handleArrow: jt,
    handleSwipe: _t,
    selectCurrentDate: () => {
      e.range ? u.value && Array.isArray(u.value) && u.value[0] ? u.value = Pe(w(), u.value[0]) ? [w(), u.value[0]] : [u.value[0], w()] : u.value = [w()] : u.value = w(), i();
    },
    presetDateRange: (o, b) => {
      b || o.length && o.length <= 2 && e.range && (u.value = o.map((j) => w(j)), i());
    }
  };
}, Vr = (e, n, a) => {
  const t = W(), {
    getZonedToUtc: l,
    getZonedDate: c,
    formatDate: k,
    getDefaultPattern: M,
    checkRangeEnabled: O,
    checkPartialRangeValue: I,
    isValidDate: F,
    setDateMonthOrYear: C,
    defaults: u
  } = Ve(n), T = W("");
  ft(t, () => {
    e("internal-model-change", t.value);
  });
  const U = (v) => {
    const i = v || w();
    return {
      hours: Ke(i),
      minutes: xe(i),
      seconds: n.enableSeconds ? dt(i) : 0
    };
  }, V = (v) => ({ month: he(v), year: ge(v) }), J = (v) => Array.isArray(v) ? O(() => [
    lt(w(), v[0]),
    v[1] ? lt(w(), v[1]) : I()
  ]) : lt(w(), +v), B = (v) => Array.isArray(v) ? [
    Le(null, +v[0].hours, +v[0].minutes, v[0].seconds),
    Le(null, +v[1].hours, +v[1].minutes, v[1].seconds)
  ] : Le(null, v.hours, v.minutes, v == null ? void 0 : v.seconds), E = (v) => Array.isArray(v) ? O(() => [
    C(null, +v[0].month, +v[0].year),
    v[1] ? C(null, +v[1].month, +v[1].year) : I()
  ]) : C(null, +v.month, +v.year), N = (v) => {
    if (Array.isArray(v))
      return v.map((i) => d(i));
    throw new Error(Lt.dateArr("multi-dates"));
  }, K = (v) => {
    if (Array.isArray(v))
      return [w(v[0]), w(v[1])];
    throw new Error(Lt.dateArr("week-picker"));
  }, te = (v) => n.modelAuto ? Array.isArray(v) ? [d(v[0]), d(v[1])] : n.autoApply ? [d(v)] : [d(v), null] : Array.isArray(v) ? O(() => [
    d(v[0]),
    v[1] ? d(v[1]) : I()
  ]) : d(v), le = () => {
    Array.isArray(t.value) && n.range && t.value.length === 1 && t.value.push(I());
  }, f = () => {
    const v = t.value;
    return [
      r(v[0]),
      v[1] ? r(v[1]) : I()
    ];
  }, D = () => t.value[1] ? f() : r(Me(t.value[0])), L = () => (t.value || []).map((v) => r(v)), x = () => (le(), n.modelAuto ? D() : n.multiDates ? L() : Array.isArray(t.value) ? O(() => f()) : r(Me(t.value))), R = (v) => v ? n.timePicker ? B(Me(v)) : n.monthPicker ? E(Me(v)) : n.yearPicker ? J(Me(v)) : n.multiDates ? N(Me(v)) : n.weekPicker ? K(Me(v)) : te(Me(v)) : null, Z = (v) => {
    const i = R(v);
    F(Me(i)) ? (t.value = Me(i), z()) : (t.value = null, T.value = "");
  }, ne = () => {
    var i;
    const v = (S) => {
      var fe;
      return kt(S, (fe = u.value.textInputOptions) == null ? void 0 : fe.format);
    };
    return `${v(t.value[0])} ${(i = u.value.textInputOptions) == null ? void 0 : i.rangeSeparator} ${t.value[1] ? v(t.value[1]) : ""}`;
  }, A = () => {
    var v;
    return a.value && t.value ? Array.isArray(t.value) ? ne() : kt(t.value, (v = u.value.textInputOptions) == null ? void 0 : v.format) : k(t.value);
  }, g = () => {
    var v;
    return t.value ? n.multiDates ? t.value.map((i) => k(i)).join("; ") : n.textInput && typeof ((v = u.value.textInputOptions) == null ? void 0 : v.format) == "string" ? A() : k(t.value) : "";
  }, z = () => {
    !n.format || typeof n.format == "string" ? T.value = g() : T.value = n.format(t.value);
  }, d = (v) => {
    if (n.utc) {
      const i = new Date(v);
      return n.utc === "preserve" ? new Date(i.getTime() + i.getTimezoneOffset() * 6e4) : i;
    }
    return n.modelType ? n.modelType === "date" || n.modelType === "timestamp" ? c(new Date(v)) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? rn(v, M(), new Date()) : c(rn(v, n.modelType, new Date())) : c(new Date(v));
  }, r = (v) => n.utc ? Ja(v, n.utc === "preserve") : n.modelType ? n.modelType === "timestamp" ? +l(v) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? k(l(v)) : k(l(v), n.modelType) : l(v), m = (v) => {
    e("update:model-value", v);
  }, h = (v) => Array.isArray(t.value) ? [
    v(t.value[0]),
    t.value[1] ? v(t.value[1]) : I()
  ] : v(Me(t.value)), $ = (v) => m(Me(h(v)));
  return {
    inputValue: T,
    internalModelValue: t,
    checkBeforeEmit: () => t.value ? n.range ? n.partialRange ? t.value.length >= 1 : t.value.length === 2 : !!t.value : !1,
    parseExternalModelValue: Z,
    formatInputValue: z,
    emitModelValue: () => (z(), n.monthPicker ? $(V) : n.timePicker ? $(U) : n.yearPicker ? $(ge) : n.weekPicker ? m(t.value) : m(x()))
  };
}, Lr = (e, n) => {
  const { validateMonthYearInRange: a, validateMaxDate: t, validateMinDate: l, defaults: c } = Ve(e), k = (C, u) => {
    let T = C;
    return c.value.filters.months.includes(he(T)) ? (T = u ? at(C, 1) : wt(C, 1), k(T, u)) : T;
  }, M = (C, u) => {
    let T = C;
    return c.value.filters.years.includes(ge(T)) ? (T = u ? sa(C, 1) : ia(C, 1), M(T, u)) : T;
  }, O = (C) => {
    const u = Re(new Date(), { month: e.month, year: e.year });
    let T = C ? at(u, 1) : wt(u, 1), U = he(T), V = ge(T);
    c.value.filters.months.includes(U) && (T = k(T, C), U = he(T), V = ge(T)), c.value.filters.years.includes(V) && (T = M(T, C), V = ge(T)), a(U, V, C, e.preventMinMaxNavigation) && I(U, V);
  }, I = (C, u) => {
    n("update-month-year", { month: C, year: u });
  }, F = Y(() => (C) => {
    if (!e.preventMinMaxNavigation || C && !e.maxDate || !C && !e.minDate)
      return !1;
    const u = Re(new Date(), { month: e.month, year: e.year }), T = C ? at(u, 1) : wt(u, 1), U = [he(T), ge(T)];
    return C ? !t(...U) : !l(...U);
  });
  return { handleMonthYearChange: O, isDisabled: F, updateMonthYear: I };
};
var It = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(It || {});
const Er = (e, n, a, t) => {
  const l = W({
    top: "0",
    left: "0",
    transform: "none"
  }), c = W(!1), k = an(t, "teleportCenter");
  ft(k, () => {
    J();
  });
  const M = (f) => {
    const D = f.getBoundingClientRect();
    return {
      left: D.left + window.scrollX,
      top: D.top + window.scrollY
    };
  }, O = (f) => {
    const D = f.getBoundingClientRect();
    let L = 0, x = 0;
    for (; f && !isNaN(f.offsetLeft) && !isNaN(f.offsetTop); )
      L += f.offsetLeft - f.scrollLeft, x = D.top + f.scrollTop, f = f.offsetParent;
    return { top: x, left: L };
  }, I = (f, D) => {
    l.value.left = `${f + D}px`, l.value.transform = "translateX(-100%)";
  }, F = (f) => {
    l.value.left = `${f}px`, l.value.transform = "translateX(0)";
  }, C = (f, D, L = !1) => {
    t.position === It.left && F(f), t.position === It.right && I(f, D), t.position === It.center && (l.value.left = `${f + D / 2}px`, l.value.transform = L ? "translate(-50%, -50%)" : "translateX(-50%)");
  }, u = (f) => {
    const { width: D, height: L } = f.getBoundingClientRect(), { top: x, left: R } = t.altPosition ? O(f) : M(f);
    return { top: x, left: R, width: D, height: L };
  }, T = () => {
    const f = Ce(n);
    if (f) {
      const { top: D, left: L, width: x, height: R } = u(f);
      l.value.top = `${D + R / 2}px`, l.value.transform = "translateY(-50%)", C(L, x, !0);
    }
  }, U = () => {
    l.value.left = "50%", l.value.top = "50%", l.value.transform = "translate(-50%, -50%)", l.value.position = "fixed";
  }, V = () => {
    const f = Ce(n);
    l.value = t.altPosition(f);
  }, J = (f = !0) => {
    if (!t.inline)
      return k.value ? U() : t.altPosition && typeof t.altPosition != "boolean" ? V() : (f && a("recalculate-position"), le());
  }, B = ({
    inputEl: f,
    menuEl: D,
    left: L,
    width: x
  }) => {
    window.screen.width > 768 && C(L, x), K(f, D);
  }, E = (f, D) => {
    const { top: L, left: x, height: R, width: Z } = u(f);
    l.value.top = `${R + L + +t.offset}px`, B({ inputEl: f, menuEl: D, left: x, width: Z }), c.value = !1;
  }, N = (f, D) => {
    const { top: L, left: x, width: R } = u(f), { height: Z } = D.getBoundingClientRect();
    l.value.top = `${L - Z - +t.offset}px`, B({ inputEl: f, menuEl: D, left: x, width: R }), c.value = !0;
  }, K = (f, D) => {
    if (t.autoPosition) {
      const { left: L, width: x } = u(f), { left: R, right: Z } = D.getBoundingClientRect();
      if (R < 0)
        return F(L);
      if (Z > document.documentElement.clientWidth)
        return I(L, x);
    }
  }, te = (f, D) => {
    const { height: L } = D.getBoundingClientRect(), { top: x, height: R } = f.getBoundingClientRect(), ne = window.innerHeight - x - R, A = x;
    return L <= ne ? E(f, D) : L > ne && L <= A ? N(f, D) : ne >= A ? E(f, D) : N(f, D);
  }, le = () => {
    const f = Ce(n), D = Ce(e);
    if (f && D)
      return t.autoPosition ? te(f, D) : E(f, D);
  };
  return { openOnTop: c, menuPosition: l, setMenuPosition: J, setInitialPosition: T };
}, it = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay-value", use: ["calendar", "month-year"] },
  { name: "year-overlay-value", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["month-year"] },
  { name: "month-overlay", use: ["month-year"] },
  { name: "month-overlay-header", use: ["month-year"] },
  { name: "year-overlay-header", use: ["month-year"] },
  { name: "hours-overlay-value", use: ["calendar", "time"] },
  { name: "minutes-overlay-value", use: ["calendar", "time"] },
  { name: "seconds-overlay-value", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year"] },
  { name: "time-picker", use: ["menu"] },
  { name: "action-row", use: ["action"] }
], Fr = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], Ur = {
  all: () => it,
  monthYear: () => it.filter((e) => e.use.includes("month-year")),
  input: () => Fr,
  timePicker: () => it.filter((e) => e.use.includes("time")),
  action: () => it.filter((e) => e.use.includes("action")),
  calendar: () => it.filter((e) => e.use.includes("calendar")),
  menu: () => it.filter((e) => e.use.includes("menu"))
}, rt = (e, n, a) => {
  const t = [];
  return Ur[n]().forEach((l) => {
    e[l.name] && t.push(l.name);
  }), a && a.length && a.forEach((l) => {
    l.slot && t.push(l.slot);
  }), t;
}, Ft = (e) => ({ transitionName: Y(() => (a) => e && typeof e != "boolean" ? a ? e.open : e.close : ""), showTransition: !!e }), Qe = {
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: !1 },
  autoPosition: { type: Boolean, default: !0 },
  closeOnAutoApply: { type: Boolean, default: !0 },
  teleport: { type: [String, Object], default: "body" },
  altPosition: { type: [Boolean, Function], default: !1 },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: String, default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: !1 },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  monthYearComponent: { type: Object, default: null },
  timePickerComponent: { type: Object, default: null },
  actionRowComponent: { type: Object, default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: !1 },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  keepActionRow: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  multiStatic: { type: Boolean, default: !0 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: !1 },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: { type: Boolean, default: !1 },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: !1 },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: !1 },
  textInputOptions: { type: Object, default: () => null },
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: Boolean, default: !1 },
  textInput: { type: Boolean, default: !1 },
  onClickOutside: { type: Function, default: null },
  noDisabledRange: { type: Boolean, default: !1 },
  sixWeeks: { type: Boolean, default: !1 }
}, Hr = ["aria-label", "aria-disabled", "aria-readonly"], Wr = {
  key: 1,
  class: "dp__input_wrap"
}, zr = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"], jr = {
  key: 2,
  class: "dp__input_icon"
}, Kr = {
  key: 4,
  class: "dp__clear_icon"
}, xr = /* @__PURE__ */ Ue({
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...Qe
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { getDefaultPattern: l, isValidDate: c, defaults: k } = Ve(t), M = W(), O = W(null), I = W(!1), F = Y(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !t.textInput,
        dp__disabled: t.disabled,
        dp__input_readonly: !t.textInput,
        dp__input: !0,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: t.state,
        dp__input_invalid: t.state === !1,
        dp__input_focus: I.value || t.isMenuOpen,
        dp__input_reg: !t.textInput,
        [t.inputClassName]: !!t.inputClassName
      })
    ), C = () => {
      a("set-input-date", null), t.autoApply && (a("set-empty-date"), M.value = null);
    }, u = (f) => {
      var D;
      return qa(f, ((D = k.value.textInputOptions) == null ? void 0 : D.format) || l());
    }, T = (f) => {
      const { rangeSeparator: D } = k.value.textInputOptions;
      if (t.range) {
        const [L, x] = f.split(`${D}`);
        if (L && x) {
          const R = u(L.trim()), Z = u(x.trim());
          M.value = R && Z ? [R, Z] : null;
        }
      } else if (t.multiDates) {
        const L = f.split(";");
        M.value = L.map((x) => u(x.trim())).filter((x) => x);
      } else
        M.value = u(f);
    }, U = (f) => {
      var L;
      const { value: D } = f.target;
      D !== "" ? (((L = k.value.textInputOptions) == null ? void 0 : L.openMenu) && !t.isMenuOpen && a("open"), T(D), a("set-input-date", M.value)) : C(), a("update:input-value", D);
    }, V = () => {
      var f, D;
      ((f = k.value.textInputOptions) == null ? void 0 : f.enterSubmit) && c(M.value) && t.inputValue !== "" ? (a("set-input-date", M.value, !0), M.value = null) : ((D = k.value.textInputOptions) == null ? void 0 : D.enterSubmit) && t.inputValue === "" && (M.value = null, a("clear"));
    }, J = () => {
      var f, D;
      ((f = k.value.textInputOptions) == null ? void 0 : f.tabSubmit) && c(M.value) && t.inputValue !== "" ? (a("set-input-date", M.value, !0), M.value = null) : ((D = k.value.textInputOptions) == null ? void 0 : D.tabSubmit) && t.inputValue === "" && (M.value = null, a("clear"));
    }, B = () => {
      I.value = !0, a("focus");
    }, E = (f) => {
      var D;
      f.preventDefault(), f.stopImmediatePropagation(), f.stopPropagation(), t.textInput && ((D = k.value.textInputOptions) == null ? void 0 : D.openMenu) && !t.inlineWithInput ? t.isMenuOpen ? k.value.textInputOptions.enterSubmit && a("select-date") : a("open") : t.textInput || a("toggle");
    }, N = () => {
      I.value = !1, t.isMenuOpen || a("blur"), t.autoApply && t.textInput && M.value && (a("set-input-date", M.value), a("select-date"), M.value = null);
    }, K = () => {
      a("clear");
    }, te = (f) => {
      t.textInput || f.preventDefault();
    };
    return n({
      focusInput: () => {
        O.value && O.value.focus({ preventScroll: !0 });
      }
    }), (f, D) => {
      var L;
      return p(), P("div", {
        onClick: E,
        "aria-label": (L = s(k).ariaLabels) == null ? void 0 : L.input,
        role: "textbox",
        "aria-multiline": "false",
        "aria-disabled": f.disabled,
        "aria-readonly": f.readonly
      }, [
        f.$slots.trigger && !f.$slots["dp-input"] && !f.inline ? H(f.$slots, "trigger", { key: 0 }) : _("", !0),
        !f.$slots.trigger && (!f.inline || f.inlineWithInput) ? (p(), P("div", Wr, [
          f.$slots["dp-input"] && !f.$slots.trigger && !f.inline ? H(f.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            onInput: U,
            onEnter: V,
            onTab: J,
            onClear: K
          }) : _("", !0),
          f.$slots["dp-input"] ? _("", !0) : (p(), P("input", {
            key: 1,
            ref_key: "inputRef",
            ref: O,
            id: f.uid ? `dp-input-${f.uid}` : void 0,
            name: f.name,
            class: ve(s(F)),
            inputmode: f.textInput ? "text" : "none",
            placeholder: f.placeholder,
            disabled: f.disabled,
            readonly: f.readonly,
            required: f.required,
            value: e.inputValue,
            autocomplete: f.autocomplete,
            onInput: U,
            onKeydown: [
              ie(E, ["enter"]),
              ie(J, ["tab"])
            ],
            onBlur: N,
            onFocus: B,
            onKeypress: te
          }, null, 42, zr)),
          f.$slots["input-icon"] && !f.hideInputIcon ? (p(), P("span", jr, [
            H(f.$slots, "input-icon")
          ])) : _("", !0),
          !f.$slots["input-icon"] && !f.hideInputIcon && !f.$slots["dp-input"] ? (p(), de(s(Et), {
            key: 3,
            class: "dp__input_icon dp__input_icons"
          })) : _("", !0),
          f.$slots["clear-icon"] && e.inputValue && f.clearable && !f.disabled && !f.readonly ? (p(), P("span", Kr, [
            H(f.$slots, "clear-icon", { clear: K })
          ])) : _("", !0),
          f.clearable && !f.$slots["clear-icon"] && e.inputValue && !f.disabled && !f.readonly ? (p(), de(s(Ma), {
            key: 5,
            class: "dp__clear_icon dp__input_icons",
            "data-test": "clear-icon",
            onClick: Ge(K, ["stop", "prevent"])
          }, null, 8, ["onClick"])) : _("", !0)
        ])) : _("", !0)
      ], 8, Hr);
    };
  }
}), Gr = { class: "dp__selection_preview" }, Zr = { class: "dp__action_buttons" }, Xr = ["onKeydown"], qr = /* @__PURE__ */ Ue({
  __name: "ActionRow",
  props: {
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    ...Qe
  },
  emits: ["close-picker", "select-date", "invalid-select"],
  setup(e, { emit: n }) {
    const a = e, { formatDate: t, isValidTime: l, defaults: c } = Ve(a), { buildMatrix: k } = Je(), M = W(null), O = W(null);
    Fe(() => {
      a.arrowNavigation && k([Ce(M), Ce(O)], "actionRow");
    });
    const I = Y(() => a.range && !a.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : !0), F = Y(() => !u.value || !T.value || !I.value), C = Y(() => ({
      dp__action: !0,
      dp__select: !0,
      dp__action_disabled: F.value
    })), u = Y(() => !a.enableTimePicker || a.ignoreTimeValidation ? !0 : l(a.internalModelValue)), T = Y(() => a.monthPicker ? B(a.internalModelValue) : !0), U = () => {
      const N = c.value.previewFormat;
      return a.timePicker || a.monthPicker, N(Me(a.internalModelValue));
    }, V = () => {
      const N = a.internalModelValue;
      return c.value.multiCalendars > 0 ? `${t(N[0])} - ${t(N[1])}` : [t(N[0]), t(N[1])];
    }, J = Y(() => !a.internalModelValue || !a.menuMount ? "" : typeof c.value.previewFormat == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? V() : a.multiDates ? a.internalModelValue.map((N) => `${t(N)}`) : a.modelAuto ? `${t(a.internalModelValue[0])}` : `${t(a.internalModelValue[0])} -` : t(a.internalModelValue) : U()), B = (N) => {
      if (!a.monthPicker)
        return !0;
      let K = !0;
      return a.minDate && a.maxDate ? Oe(w(N), w(a.minDate)) && Pe(w(N), w(a.maxDate)) : (a.minDate && (K = Oe(w(N), w(a.minDate))), a.maxDate && (K = Pe(w(N), w(a.maxDate))), K);
    }, E = () => {
      u.value && T.value && I.value ? n("select-date") : n("invalid-select");
    };
    return (N, K) => (p(), P("div", {
      class: "dp__action_row",
      style: ut(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      N.$slots["action-row"] ? H(N.$slots, "action-row", Ye(Ae({ key: 0 }, {
        internalModelValue: e.internalModelValue,
        disabled: s(F),
        selectDate: () => N.$emit("select-date"),
        closePicker: () => N.$emit("close-picker")
      }))) : (p(), P(ce, { key: 1 }, [
        ee("div", Gr, [
          N.$slots["action-preview"] ? H(N.$slots, "action-preview", {
            key: 0,
            value: e.internalModelValue
          }) : _("", !0),
          N.$slots["action-preview"] ? _("", !0) : (p(), P(ce, { key: 1 }, [
            Array.isArray(s(J)) ? _("", !0) : (p(), P(ce, { key: 0 }, [
              We(Se(s(J)), 1)
            ], 64)),
            Array.isArray(s(J)) ? (p(!0), P(ce, { key: 1 }, De(s(J), (te, le) => (p(), P("div", { key: le }, Se(te), 1))), 128)) : _("", !0)
          ], 64))
        ]),
        ee("div", Zr, [
          N.$slots["action-select"] ? H(N.$slots, "action-select", {
            key: 0,
            value: e.internalModelValue
          }) : _("", !0),
          N.$slots["action-select"] ? _("", !0) : (p(), P(ce, { key: 1 }, [
            N.inline ? _("", !0) : (p(), P("span", {
              key: 0,
              class: "dp__action dp__cancel",
              ref_key: "cancelButtonRef",
              ref: M,
              tabindex: "0",
              onClick: K[0] || (K[0] = (te) => N.$emit("close-picker")),
              onKeydown: [
                K[1] || (K[1] = ie((te) => N.$emit("close-picker"), ["enter"])),
                K[2] || (K[2] = ie((te) => N.$emit("close-picker"), ["space"]))
              ]
            }, Se(N.cancelText), 545)),
            ee("span", {
              class: ve(s(C)),
              tabindex: "0",
              onKeydown: [
                ie(E, ["enter"]),
                ie(E, ["space"])
              ],
              onClick: E,
              "data-test": "select-button",
              ref_key: "selectButtonRef",
              ref: O
            }, Se(N.selectText), 43, Xr)
          ], 64))
        ])
      ], 64))
    ], 4));
  }
}), Jr = ["aria-label"], Qr = {
  class: "dp__calendar_header",
  role: "row"
}, el = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, tl = /* @__PURE__ */ ee("div", { class: "dp__calendar_header_separator" }, null, -1), nl = ["aria-label"], al = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, rl = { class: "dp__cell_inner" }, ll = ["aria-selected", "aria-disabled", "aria-label", "data-test", "onClick", "onKeydown", "onMouseover"], ol = /* @__PURE__ */ ee("div", { class: "dp__arrow_bottom_tp" }, null, -1), sl = /* @__PURE__ */ Ue({
  __name: "Calendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    specificMode: { type: Boolean, default: !1 },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...Qe
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMultiLevelMatrix: l } = Je(), { setDateMonthOrYear: c, defaults: k } = Ve(t), M = W(null), O = W({ bottom: "", left: "", transform: "" }), I = W([]), F = W(null), C = W(!0), u = W(""), T = W({ startX: 0, endX: 0, startY: 0, endY: 0 }), U = Y(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : _r(t.locale, +t.weekStart));
    Fe(() => {
      a("mount", { cmp: "calendar", refs: I }), t.noSwipe || F.value && (F.value.addEventListener("touchstart", L, { passive: !1 }), F.value.addEventListener("touchend", x, { passive: !1 }), F.value.addEventListener("touchmove", R, { passive: !1 })), t.monthChangeOnScroll && F.value && F.value.addEventListener("wheel", A, { passive: !1 });
    });
    const V = (g) => g ? t.vertical ? "vNext" : "next" : t.vertical ? "vPrevious" : "previous", J = (g, z) => {
      if (t.transitions) {
        const d = ze(c(w(), t.month, t.year));
        u.value = Oe(ze(c(w(), g, z)), d) ? k.value.transitions[V(!0)] : k.value.transitions[V(!1)], C.value = !1, Dt(() => {
          C.value = !0;
        });
      }
    }, B = Y(
      () => ({
        dp__calendar_wrap: !0,
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), E = Y(() => (g) => {
      const z = Cr(g);
      return {
        dp__marker_dot: z.type === "dot",
        dp__marker_line: z.type === "line"
      };
    }), N = Y(() => (g) => pe(g, M.value)), K = Y(() => ({
      dp__calendar: !0,
      dp__calendar_next: k.value.multiCalendars > 0 && t.instance !== 0
    })), te = Y(() => (g) => t.hideOffsetDates ? g.current : !0), le = Y(() => t.specificMode ? { height: `${t.modeHeight}px` } : void 0), f = (g, z, d) => {
      var r, m;
      if (a("set-hover-date", g), (m = (r = g.marker) == null ? void 0 : r.tooltip) != null && m.length) {
        const h = Ce(I.value[z][d]);
        if (h) {
          const { width: $, height: X } = h.getBoundingClientRect();
          O.value = {
            bottom: `${X}px`,
            left: `${$ / 2}px`,
            transform: "translateX(-50%)"
          }, M.value = g.value;
        }
      }
    }, D = () => {
      M.value = null;
    }, L = (g) => {
      T.value.startX = g.changedTouches[0].screenX, T.value.startY = g.changedTouches[0].screenY;
    }, x = (g) => {
      T.value.endX = g.changedTouches[0].screenX, T.value.endY = g.changedTouches[0].screenY, Z();
    }, R = (g) => {
      t.vertical && !t.inline && g.preventDefault();
    }, Z = () => {
      const g = t.vertical ? "Y" : "X";
      Math.abs(T.value[`start${g}`] - T.value[`end${g}`]) > 10 && a("handle-swipe", T.value[`start${g}`] > T.value[`end${g}`] ? "right" : "left");
    }, ne = (g, z, d) => {
      g && (Array.isArray(I.value[z]) ? I.value[z][d] = g : I.value[z] = [g]), t.arrowNavigation && l(I.value, "calendar");
    }, A = (g) => {
      t.monthChangeOnScroll && (g.preventDefault(), a("handle-scroll", g));
    };
    return n({ triggerTransition: J }), (g, z) => {
      var d;
      return p(), P("div", {
        class: ve(s(K))
      }, [
        ee("div", {
          style: ut(s(le))
        }, [
          e.specificMode ? _("", !0) : (p(), P("div", {
            key: 0,
            ref_key: "calendarWrapRef",
            ref: F,
            class: ve(s(B)),
            role: "grid",
            "aria-label": (d = s(k).ariaLabels) == null ? void 0 : d.calendarWrap
          }, [
            ee("div", Qr, [
              g.weekNumbers ? (p(), P("div", el, Se(g.weekNumName), 1)) : _("", !0),
              (p(!0), P(ce, null, De(s(U), (r, m) => (p(), P("div", {
                class: "dp__calendar_header_item",
                role: "gridcell",
                key: m,
                "data-test": "calendar-header"
              }, [
                g.$slots["calendar-header"] ? H(g.$slots, "calendar-header", {
                  key: 0,
                  day: r,
                  index: m
                }) : _("", !0),
                g.$slots["calendar-header"] ? _("", !0) : (p(), P(ce, { key: 1 }, [
                  We(Se(r), 1)
                ], 64))
              ]))), 128))
            ]),
            tl,
            qe(mt, {
              name: u.value,
              css: !!g.transitions
            }, {
              default: se(() => {
                var r;
                return [
                  C.value ? (p(), P("div", {
                    key: 0,
                    class: "dp__calendar",
                    role: "grid",
                    "aria-label": (r = s(k).ariaLabels) == null ? void 0 : r.calendarDays
                  }, [
                    (p(!0), P(ce, null, De(e.mappedDates, (m, h) => (p(), P("div", {
                      class: "dp__calendar_row",
                      role: "row",
                      key: h
                    }, [
                      g.weekNumbers ? (p(), P("div", al, [
                        ee("div", rl, Se(e.getWeekNum(m.days)), 1)
                      ])) : _("", !0),
                      (p(!0), P(ce, null, De(m.days, ($, X) => {
                        var re, v, i;
                        return p(), P("div", {
                          role: "gridcell",
                          class: "dp__calendar_item",
                          ref_for: !0,
                          ref: (S) => ne(S, h, X),
                          key: X + h,
                          "aria-selected": $.classData.dp__active_date || $.classData.dp__range_start || $.classData.dp__range_start,
                          "aria-disabled": $.classData.dp__cell_disabled,
                          "aria-label": (v = (re = s(k).ariaLabels) == null ? void 0 : re.day) == null ? void 0 : v.call(re, $),
                          tabindex: "0",
                          "data-test": $.value,
                          onClick: Ge((S) => g.$emit("select-date", $), ["stop", "prevent"]),
                          onKeydown: [
                            ie((S) => g.$emit("select-date", $), ["enter"]),
                            ie((S) => g.$emit("handle-space", $), ["space"])
                          ],
                          onMouseover: (S) => f($, h, X),
                          onMouseleave: D
                        }, [
                          ee("div", {
                            class: ve(["dp__cell_inner", $.classData])
                          }, [
                            g.$slots.day && s(te)($) ? H(g.$slots, "day", {
                              key: 0,
                              day: +$.text,
                              date: $.value
                            }) : _("", !0),
                            g.$slots.day ? _("", !0) : (p(), P(ce, { key: 1 }, [
                              We(Se($.text), 1)
                            ], 64)),
                            $.marker && s(te)($) ? (p(), P("div", {
                              key: 2,
                              class: ve(s(E)($.marker)),
                              style: ut($.marker.color ? { backgroundColor: $.marker.color } : {})
                            }, null, 6)) : _("", !0),
                            s(N)($.value) ? (p(), P("div", {
                              key: 3,
                              class: "dp__marker_tooltip",
                              style: ut(O.value)
                            }, [
                              (i = $.marker) != null && i.tooltip ? (p(), P("div", {
                                key: 0,
                                class: "dp__tooltip_content",
                                onClick: z[0] || (z[0] = Ge(() => {
                                }, ["stop"]))
                              }, [
                                (p(!0), P(ce, null, De($.marker.tooltip, (S, fe) => (p(), P("div", {
                                  key: fe,
                                  class: "dp__tooltip_text"
                                }, [
                                  g.$slots["marker-tooltip"] ? H(g.$slots, "marker-tooltip", {
                                    key: 0,
                                    tooltop: S,
                                    day: $.value
                                  }) : _("", !0),
                                  g.$slots["marker-tooltip"] ? _("", !0) : (p(), P(ce, { key: 1 }, [
                                    ee("div", {
                                      class: "dp__tooltip_mark",
                                      style: ut(S.color ? { backgroundColor: S.color } : {})
                                    }, null, 4),
                                    ee("div", null, Se(S.text), 1)
                                  ], 64))
                                ]))), 128)),
                                ol
                              ])) : _("", !0)
                            ], 4)) : _("", !0)
                          ], 2)
                        ], 40, ll);
                      }), 128))
                    ]))), 128))
                  ], 8, nl)) : _("", !0)
                ];
              }),
              _: 3
            }, 8, ["name", "css"])
          ], 10, Jr))
        ], 4)
      ], 2);
    };
  }
}), il = ["aria-label", "aria-disabled"], tn = /* @__PURE__ */ Ue({
  __name: "ActionIcon",
  props: {
    ariaLabel: { type: String, default: "" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: n }) {
    const a = W(null);
    return Fe(() => n("set-ref", a)), (t, l) => (p(), P("div", {
      class: "dp__month_year_col_nav",
      onClick: l[0] || (l[0] = (c) => t.$emit("activate")),
      onKeydown: [
        l[1] || (l[1] = ie((c) => t.$emit("activate"), ["enter"])),
        l[2] || (l[2] = ie((c) => t.$emit("activate"), ["space"]))
      ],
      tabindex: "0",
      role: "button",
      "aria-label": e.ariaLabel,
      "aria-disabled": e.disabled,
      ref_key: "elRef",
      ref: a
    }, [
      ee("div", {
        class: ve(["dp__inner_nav", { dp__inner_nav_disabled: e.disabled }])
      }, [
        H(t.$slots, "default")
      ], 2)
    ], 40, il));
  }
}), ul = ["onKeydown"], cl = { class: "dp__selection_grid_header" }, dl = ["aria-selected", "aria-disabled", "data-test", "onClick", "onKeydown", "onMouseover"], fl = ["aria-label", "onKeydown"], bt = /* @__PURE__ */ Ue({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: !1 },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: !1 },
    monthPicker: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 },
    escClose: { type: Boolean, default: !0 },
    type: { type: String, default: null },
    arrowNavigation: { type: Boolean, default: !1 },
    autoApply: { type: Boolean, default: !1 },
    textInput: { type: Boolean, default: !1 },
    ariaLabels: { type: Object, default: () => ({}) },
    hideNavigation: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "selected", "toggle", "reset-flow"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setSelectionGrid: l, buildMultiLevelMatrix: c, setMonthPicker: k } = Je(), { hideNavigationButtons: M } = Ve(t), O = W(!1), I = W(null), F = W(null), C = W([]), u = W(), T = W(null);
    qn(() => {
      I.value = null;
    }), Fe(() => {
      Dt().then(() => f()), V(), U(!0);
    }), sn(() => U(!1));
    const U = (A) => {
      var g;
      t.arrowNavigation && ((g = t.headerRefs) != null && g.length ? k(A) : l(A));
    }, V = () => {
      const A = Ce(F);
      A && (t.textInput || A.focus({ preventScroll: !0 }), O.value = A.clientHeight < A.scrollHeight);
    }, J = Y(
      () => ({
        dp__overlay: !0
      })
    ), B = Y(() => ({
      dp__overlay_col: !0
    })), E = (A) => t.skipActive ? !1 : A.value === t.modelValue, N = Y(() => t.items.map((A) => A.filter((g) => g).map((g) => {
      var r, m, h;
      const z = t.disabledValues.some(($) => $ === g.value) || le(g.value), d = (r = t.multiModelValue) != null && r.length ? (m = t.multiModelValue) == null ? void 0 : m.some(
        ($) => pe(
          $,
          lt(
            t.monthPicker ? Rt(new Date(), g.value) : new Date(),
            t.monthPicker ? t.year : g.value
          )
        )
      ) : E(g);
      return {
        ...g,
        className: {
          dp__overlay_cell_active: d,
          dp__overlay_cell: !d,
          dp__overlay_cell_disabled: z,
          dp__overlay_cell_active_disabled: z && d,
          dp__overlay_cell_pad: !0,
          dp__cell_in_between: (h = t.multiModelValue) != null && h.length ? L(g.value) : !1
        }
      };
    }))), K = Y(
      () => ({
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: O.value,
        dp__button_bottom: t.autoApply
      })
    ), te = Y(() => {
      var A, g;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((A = t.items) == null ? void 0 : A.length) <= 6,
        dp__container_block: ((g = t.items) == null ? void 0 : g.length) > 6
      };
    }), le = (A) => {
      const g = t.maxValue || t.maxValue === 0, z = t.minValue || t.minValue === 0;
      return !g && !z ? !1 : g && z ? +A > +t.maxValue || +A < +t.minValue : g ? +A > +t.maxValue : z ? +A < +t.minValue : !1;
    }, f = () => {
      const A = Ce(I);
      if (A) {
        const g = Ce(F);
        g && (g.scrollTop = A.offsetTop - g.offsetTop - (g.getBoundingClientRect().height / 2 - A.getBoundingClientRect().height));
      }
    }, D = (A) => {
      !t.disabledValues.some((g) => g === A) && !le(A) && (a("update:model-value", A), a("selected"));
    }, L = (A) => {
      const g = t.monthPicker ? t.year : A;
      return zn(
        t.multiModelValue,
        lt(
          t.monthPicker ? Rt(new Date(), u.value || 0) : new Date(),
          t.monthPicker ? g : u.value || g
        ),
        lt(t.monthPicker ? Rt(new Date(), A) : new Date(), g)
      );
    }, x = () => {
      a("toggle"), a("reset-flow");
    }, R = () => {
      t.escClose && x();
    }, Z = (A, g, z, d) => {
      A && (g.value === +t.modelValue && !t.disabledValues.includes(g.value) && (I.value = A), t.arrowNavigation && (Array.isArray(C.value[z]) ? C.value[z][d] = A : C.value[z] = [A], ne()));
    }, ne = () => {
      var g, z;
      const A = (g = t.headerRefs) != null && g.length ? [t.headerRefs].concat(C.value) : C.value.concat([t.skipButtonRef ? [] : [T.value]]);
      c(Me(A), (z = t.headerRefs) != null && z.length ? "monthPicker" : "selectionGrid");
    };
    return n({ focusGrid: V }), (A, g) => {
      var z;
      return p(), P("div", {
        ref_key: "gridWrapRef",
        ref: F,
        class: ve(s(J)),
        role: "dialog",
        tabindex: "0",
        onKeydown: ie(R, ["esc"])
      }, [
        ee("div", {
          class: ve(s(te)),
          role: "grid"
        }, [
          ee("div", cl, [
            H(A.$slots, "header")
          ]),
          A.$slots.overlay ? H(A.$slots, "overlay", { key: 0 }) : (p(), P(ce, { key: 1 }, [
            (p(!0), P(ce, null, De(s(N), (d, r) => (p(), P("div", {
              class: "dp__overlay_row",
              key: r,
              role: "row"
            }, [
              (p(!0), P(ce, null, De(d, (m, h) => (p(), P("div", {
                role: "gridcell",
                class: ve(s(B)),
                key: m.value,
                "aria-selected": m.value === e.modelValue && !e.disabledValues.includes(m.value),
                "aria-disabled": m.className.dp__overlay_cell_disabled,
                ref_for: !0,
                ref: ($) => Z($, m, r, h),
                tabindex: "0",
                "data-test": m.text,
                onClick: ($) => D(m.value),
                onKeydown: [
                  ie(($) => D(m.value), ["enter"]),
                  ie(($) => D(m.value), ["space"])
                ],
                onMouseover: ($) => u.value = m.value
              }, [
                ee("div", {
                  class: ve(m.className)
                }, [
                  A.$slots.item ? H(A.$slots, "item", {
                    key: 0,
                    item: m
                  }) : _("", !0),
                  A.$slots.item ? _("", !0) : (p(), P(ce, { key: 1 }, [
                    We(Se(m.text), 1)
                  ], 64))
                ], 2)
              ], 42, dl))), 128))
            ]))), 128)),
            A.$slots["button-icon"] ? St((p(), P("div", {
              key: 0,
              role: "button",
              "aria-label": (z = e.ariaLabels) == null ? void 0 : z.toggleOverlay,
              class: ve(s(K)),
              tabindex: "0",
              ref_key: "toggleButton",
              ref: T,
              onClick: x,
              onKeydown: ie(x, ["enter"])
            }, [
              H(A.$slots, "button-icon")
            ], 42, fl)), [
              [Ct, !s(M)(e.type)]
            ]) : _("", !0)
          ], 64))
        ], 2)
      ], 42, ul);
    };
  }
}), ml = ["aria-label"], Bn = /* @__PURE__ */ Ue({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: !1 },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    overlaySlot: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] },
    escClose: { type: Boolean, default: !0 },
    type: { type: String, default: null },
    transitions: { type: [Object, Boolean], default: !1 },
    arrowNavigation: { type: Boolean, default: !1 },
    autoApply: { type: Boolean, default: !1 },
    textInput: { type: Boolean, default: !1 },
    ariaLabels: { type: Object, default: () => ({}) },
    hideNavigation: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "set-ref"],
  setup(e, { emit: n }) {
    const a = e, { transitionName: t, showTransition: l } = Ft(a.transitions), c = W(null);
    return Fe(() => n("set-ref", c)), (k, M) => (p(), P(ce, null, [
      ee("div", {
        class: "dp__month_year_select",
        onClick: M[0] || (M[0] = (O) => k.$emit("toggle")),
        onKeydown: [
          M[1] || (M[1] = ie((O) => k.$emit("toggle"), ["enter"])),
          M[2] || (M[2] = ie((O) => k.$emit("toggle"), ["space"]))
        ],
        role: "button",
        "aria-label": e.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: c
      }, [
        H(k.$slots, "default")
      ], 40, ml),
      qe(mt, {
        name: s(t)(e.showSelectionGrid),
        css: s(l)
      }, {
        default: se(() => [
          e.showSelectionGrid ? (p(), de(bt, Ae({ key: 0 }, {
            modelValue: e.modelValue,
            items: e.items,
            disabledValues: e.disabledValues,
            minValue: e.minValue,
            maxValue: e.maxValue,
            escClose: e.escClose,
            type: e.type,
            arrowNavigation: e.arrowNavigation,
            textInput: e.textInput,
            autoApply: e.autoApply,
            ariaLabels: e.ariaLabels,
            hideNavigation: e.hideNavigation
          }, {
            "header-refs": [],
            "onUpdate:modelValue": M[3] || (M[3] = (O) => k.$emit("update:model-value", O)),
            onToggle: M[4] || (M[4] = (O) => k.$emit("toggle"))
          }), Be({
            "button-icon": se(() => [
              k.$slots["calendar-icon"] ? H(k.$slots, "calendar-icon", { key: 0 }) : _("", !0),
              k.$slots["calendar-icon"] ? _("", !0) : (p(), de(s(Et), { key: 1 }))
            ]),
            _: 2
          }, [
            k.$slots[e.slotName] ? {
              name: "item",
              fn: se(({ item: O }) => [
                H(k.$slots, e.slotName, { item: O })
              ]),
              key: "0"
            } : void 0,
            k.$slots[e.overlaySlot] ? {
              name: "overlay",
              fn: se(() => [
                H(k.$slots, e.overlaySlot)
              ]),
              key: "1"
            } : void 0,
            k.$slots[`${e.overlaySlot}-header`] ? {
              name: "header",
              fn: se(() => [
                H(k.$slots, `${e.overlaySlot}-header`)
              ]),
              key: "2"
            } : void 0
          ]), 1040)) : _("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
}), vl = { class: "dp__month_year_row" }, yl = { class: "dp__month_year_wrap" }, hl = { class: "dp__month_picker_header" }, gl = ["aria-label"], pl = ["aria-label"], kl = ["aria-label"], wl = /* @__PURE__ */ Ue({
  __name: "MonthYearPicker",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    internalModelValue: { type: [Date, Array], default: null },
    ...Qe
  },
  emits: ["update-month-year", "month-year-select", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { defaults: l } = Ve(t), { transitionName: c, showTransition: k } = Ft(l.value.transitions), { buildMatrix: M } = Je(), { handleMonthYearChange: O, isDisabled: I, updateMonthYear: F } = Lr(t, a), C = W(!1), u = W(!1), T = W([null, null, null, null]), U = W(null), V = W(null), J = W(null);
    Fe(() => {
      a("mount");
    });
    const B = (i) => ({
      get: () => t[i],
      set: (S) => {
        const fe = i === "month" ? "year" : "month";
        a("update-month-year", { [i]: S, [fe]: t[fe] }), a("month-year-select", i === "year"), i === "month" ? h(!0) : $(!0);
      }
    }), E = Y(B("month")), N = Y(B("year")), K = (i) => {
      const S = ge(w(i));
      return t.year === S;
    }, te = Y(() => t.monthPicker ? Array.isArray(t.disabledDates) ? t.disabledDates.map((i) => w(i)).filter((i) => K(i)).map((i) => he(i)) : [] : []), le = Y(() => (i) => {
      const S = i === "month";
      return {
        showSelectionGrid: (S ? C : u).value,
        items: (S ? z : d).value,
        disabledValues: l.value.filters[S ? "months" : "years"].concat(te.value),
        minValue: (S ? x : D).value,
        maxValue: (S ? R : L).value,
        headerRefs: S && t.monthPicker ? [U.value, V.value, J.value] : [],
        escClose: t.escClose,
        transitions: l.value.transitions,
        ariaLabels: l.value.ariaLabels,
        textInput: t.textInput,
        autoApply: t.autoApply,
        arrowNavigation: t.arrowNavigation,
        hideNavigation: t.hideNavigation
      };
    }), f = Y(() => (i) => ({
      month: t.month,
      year: t.year,
      items: i === "month" ? t.months : t.years,
      instance: t.instance,
      updateMonthYear: F,
      toggle: i === "month" ? h : $
    })), D = Y(() => t.minDate ? ge(w(t.minDate)) : null), L = Y(() => t.maxDate ? ge(w(t.maxDate)) : null), x = Y(() => {
      if (t.minDate && D.value) {
        if (D.value > t.year)
          return 12;
        if (D.value === t.year)
          return he(w(t.minDate));
      }
      return null;
    }), R = Y(() => t.maxDate && L.value ? L.value < t.year ? -1 : L.value === t.year ? he(w(t.maxDate)) : null : null), Z = Y(() => t.range && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), ne = (i) => i.reverse(), A = (i, S = !1) => {
      const fe = [], $e = (be) => S ? ne(be) : be;
      for (let be = 0; be < i.length; be += 3) {
        const He = [i[be], i[be + 1], i[be + 2]];
        fe.push($e(He));
      }
      return S ? fe.reverse() : fe;
    }, g = Y(() => {
      const i = t.months.find((S) => S.value === t.month);
      return i || { text: "", value: 0 };
    }), z = Y(() => A(t.months)), d = Y(() => A(t.years, t.reverseYears)), r = Y(() => l.value.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === 0 : !0), m = Y(() => l.value.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === l.value.multiCalendars - 1 : !0), h = (i = !1) => {
      X(i), C.value = !C.value, C.value || a("overlay-closed");
    }, $ = (i = !1) => {
      X(i), u.value = !u.value, u.value || a("overlay-closed");
    }, X = (i) => {
      i || a("reset-flow");
    }, re = (i = !1) => {
      I.value(i) || a("update-month-year", {
        year: i ? t.year + 1 : t.year - 1,
        month: t.month,
        fromNav: !0
      });
    }, v = (i, S) => {
      t.arrowNavigation && (T.value[S] = Ce(i), M(T.value, "monthYear"));
    };
    return n({
      toggleMonthPicker: h,
      toggleYearPicker: $
    }), (i, S) => {
      var fe, $e, be, He, Xe;
      return p(), P("div", vl, [
        i.$slots["month-year"] ? H(i.$slots, "month-year", Ye(Ae({ key: 0 }, { month: e.month, year: e.year, months: e.months, years: e.years, updateMonthYear: s(F), handleMonthYearChange: s(O), instance: e.instance }))) : (p(), P(ce, { key: 1 }, [
          !i.monthPicker && !i.yearPicker ? (p(), P(ce, { key: 0 }, [
            s(r) && !i.vertical ? (p(), de(tn, {
              key: 0,
              "aria-label": (fe = s(l).ariaLabels) == null ? void 0 : fe.prevMonth,
              disabled: s(I)(!1),
              onActivate: S[0] || (S[0] = (ae) => s(O)(!1)),
              onSetRef: S[1] || (S[1] = (ae) => v(ae, 0))
            }, {
              default: se(() => [
                i.$slots["arrow-left"] ? H(i.$slots, "arrow-left", { key: 0 }) : _("", !0),
                i.$slots["arrow-left"] ? _("", !0) : (p(), de(s(wn), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : _("", !0),
            ee("div", yl, [
              qe(Bn, Ae({
                type: "month",
                "slot-name": "month-overlay-val",
                "overlay-slot": "overlay-month",
                "aria-label": ($e = s(l).ariaLabels) == null ? void 0 : $e.openMonthsOverlay,
                modelValue: s(E),
                "onUpdate:modelValue": S[2] || (S[2] = (ae) => nt(E) ? E.value = ae : null)
              }, s(le)("month"), {
                onToggle: h,
                onSetRef: S[3] || (S[3] = (ae) => v(ae, 1))
              }), Be({
                default: se(() => [
                  i.$slots.month ? H(i.$slots, "month", Ye(Ae({ key: 0 }, s(g)))) : _("", !0),
                  i.$slots.month ? _("", !0) : (p(), P(ce, { key: 1 }, [
                    We(Se(s(g).text), 1)
                  ], 64))
                ]),
                _: 2
              }, [
                i.$slots["calendar-icon"] ? {
                  name: "calendar-icon",
                  fn: se(() => [
                    H(i.$slots, "calendar-icon")
                  ]),
                  key: "0"
                } : void 0,
                i.$slots["month-overlay-value"] ? {
                  name: "month-overlay-val",
                  fn: se(({ item: ae }) => [
                    H(i.$slots, "month-overlay-value", {
                      text: ae.text,
                      value: ae.value
                    })
                  ]),
                  key: "1"
                } : void 0,
                i.$slots["month-overlay"] ? {
                  name: "overlay-month",
                  fn: se(() => [
                    H(i.$slots, "month-overlay", Ye(Ze(s(f)("month"))))
                  ]),
                  key: "2"
                } : void 0,
                i.$slots["month-overlay-header"] ? {
                  name: "overlay-month-header",
                  fn: se(() => [
                    H(i.$slots, "month-overlay-header", { toggle: h })
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["aria-label", "modelValue"]),
              qe(Bn, Ae({
                type: "year",
                "slot-name": "year-overlay-val",
                "overlay-slot": "overlay-year",
                "aria-label": (be = s(l).ariaLabels) == null ? void 0 : be.openYearsOverlay,
                modelValue: s(N),
                "onUpdate:modelValue": S[4] || (S[4] = (ae) => nt(N) ? N.value = ae : null)
              }, s(le)("year"), {
                onToggle: $,
                onSetRef: S[5] || (S[5] = (ae) => v(ae, 2))
              }), Be({
                default: se(() => [
                  i.$slots.year ? H(i.$slots, "year", {
                    key: 0,
                    year: e.year
                  }) : _("", !0),
                  i.$slots.year ? _("", !0) : (p(), P(ce, { key: 1 }, [
                    We(Se(e.year), 1)
                  ], 64))
                ]),
                _: 2
              }, [
                i.$slots["calendar-icon"] ? {
                  name: "calendar-icon",
                  fn: se(() => [
                    H(i.$slots, "calendar-icon")
                  ]),
                  key: "0"
                } : void 0,
                i.$slots["year-overlay-value"] ? {
                  name: "year-overlay-val",
                  fn: se(({ item: ae }) => [
                    H(i.$slots, "year-overlay-value", {
                      text: ae.text,
                      value: ae.value
                    })
                  ]),
                  key: "1"
                } : void 0,
                i.$slots["year-overlay"] ? {
                  name: "overlay-year",
                  fn: se(() => [
                    H(i.$slots, "year-overlay", Ye(Ze(s(f)("year"))))
                  ]),
                  key: "2"
                } : void 0,
                i.$slots["year-overlay-header"] ? {
                  name: "overlay-year-header",
                  fn: se(() => [
                    H(i.$slots, "year-overlay-header", { toggle: $ })
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["aria-label", "modelValue"])
            ]),
            s(r) && i.vertical ? (p(), de(tn, {
              key: 1,
              "aria-label": (He = s(l).ariaLabels) == null ? void 0 : He.prevMonth,
              disabled: s(I)(!1),
              onActivate: S[6] || (S[6] = (ae) => s(O)(!1))
            }, {
              default: se(() => [
                i.$slots["arrow-up"] ? H(i.$slots, "arrow-up", { key: 0 }) : _("", !0),
                i.$slots["arrow-up"] ? _("", !0) : (p(), de(s(Hn), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : _("", !0),
            s(m) ? (p(), de(tn, {
              key: 2,
              ref: "rightIcon",
              disabled: s(I)(!0),
              "aria-label": (Xe = s(l).ariaLabels) == null ? void 0 : Xe.nextMonth,
              onActivate: S[7] || (S[7] = (ae) => s(O)(!0)),
              onSetRef: S[8] || (S[8] = (ae) => v(ae, 3))
            }, {
              default: se(() => [
                i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? H(i.$slots, i.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : _("", !0),
                i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? _("", !0) : (p(), de(Pt(i.vertical ? s(Wn) : s(bn)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label"])) : _("", !0)
          ], 64)) : _("", !0),
          i.monthPicker ? (p(), de(bt, Ae({ key: 1 }, s(le)("month"), {
            "skip-active": i.range,
            year: e.year,
            "multi-model-value": s(Z),
            "month-picker": "",
            modelValue: s(E),
            "onUpdate:modelValue": S[17] || (S[17] = (ae) => nt(E) ? E.value = ae : null),
            onToggle: h,
            onSelected: S[18] || (S[18] = (ae) => i.$emit("overlay-closed"))
          }), Be({
            header: se(() => {
              var ae, oe, ke;
              return [
                ee("div", hl, [
                  ee("div", {
                    class: "dp__month_year_col_nav",
                    tabindex: "0",
                    ref_key: "mpPrevIconRef",
                    ref: U,
                    onClick: S[9] || (S[9] = (me) => re(!1)),
                    onKeydown: S[10] || (S[10] = ie((me) => re(!1), ["enter"]))
                  }, [
                    ee("div", {
                      class: ve(["dp__inner_nav", { dp__inner_nav_disabled: s(I)(!1) }]),
                      role: "button",
                      "aria-label": (ae = s(l).ariaLabels) == null ? void 0 : ae.prevMonth
                    }, [
                      i.$slots["arrow-left"] ? H(i.$slots, "arrow-left", { key: 0 }) : _("", !0),
                      i.$slots["arrow-left"] ? _("", !0) : (p(), de(s(wn), { key: 1 }))
                    ], 10, gl)
                  ], 544),
                  ee("div", {
                    class: "dp__pointer",
                    role: "button",
                    ref_key: "mpYearButtonRef",
                    ref: V,
                    "aria-label": (oe = s(l).ariaLabels) == null ? void 0 : oe.openYearsOverlay,
                    tabindex: "0",
                    onClick: S[11] || (S[11] = () => $(!1)),
                    onKeydown: S[12] || (S[12] = ie(() => $(!1), ["enter"]))
                  }, [
                    i.$slots.year ? H(i.$slots, "year", {
                      key: 0,
                      year: e.year
                    }) : _("", !0),
                    i.$slots.year ? _("", !0) : (p(), P(ce, { key: 1 }, [
                      We(Se(e.year), 1)
                    ], 64))
                  ], 40, pl),
                  ee("div", {
                    class: "dp__month_year_col_nav",
                    tabindex: "0",
                    ref_key: "mpNextIconRef",
                    ref: J,
                    onClick: S[13] || (S[13] = (me) => re(!0)),
                    onKeydown: S[14] || (S[14] = ie((me) => re(!0), ["enter"]))
                  }, [
                    ee("div", {
                      class: ve(["dp__inner_nav", { dp__inner_nav_disabled: s(I)(!0) }]),
                      role: "button",
                      "aria-label": (ke = s(l).ariaLabels) == null ? void 0 : ke.nextMonth
                    }, [
                      i.$slots["arrow-right"] ? H(i.$slots, "arrow-right", { key: 0 }) : _("", !0),
                      i.$slots["arrow-right"] ? _("", !0) : (p(), de(s(bn), { key: 1 }))
                    ], 10, kl)
                  ], 544)
                ]),
                qe(mt, {
                  name: s(c)(u.value),
                  css: s(k)
                }, {
                  default: se(() => [
                    u.value ? (p(), de(bt, Ae({ key: 0 }, s(le)("year"), {
                      modelValue: s(N),
                      "onUpdate:modelValue": S[15] || (S[15] = (me) => nt(N) ? N.value = me : null),
                      onToggle: $,
                      onSelected: S[16] || (S[16] = (me) => i.$emit("overlay-closed"))
                    }), Be({
                      "button-icon": se(() => [
                        i.$slots["calendar-icon"] ? H(i.$slots, "calendar-icon", { key: 0 }) : _("", !0),
                        i.$slots["calendar-icon"] ? _("", !0) : (p(), de(s(Et), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      i.$slots["year-overlay-value"] ? {
                        name: "item",
                        fn: se(({ item: me }) => [
                          H(i.$slots, "year-overlay-value", {
                            text: me.text,
                            value: me.value
                          })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["modelValue"])) : _("", !0)
                  ]),
                  _: 3
                }, 8, ["name", "css"])
              ];
            }),
            _: 2
          }, [
            i.$slots["month-overlay-value"] ? {
              name: "item",
              fn: se(({ item: ae }) => [
                H(i.$slots, "month-overlay-value", {
                  text: ae.text,
                  value: ae.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : _("", !0),
          i.yearPicker ? (p(), de(bt, Ae({ key: 2 }, s(le)("year"), {
            modelValue: s(N),
            "onUpdate:modelValue": S[19] || (S[19] = (ae) => nt(N) ? N.value = ae : null),
            "multi-model-value": s(Z),
            "skip-active": i.range,
            "skip-button-ref": "",
            "year-picker": "",
            onToggle: $,
            onSelected: S[20] || (S[20] = (ae) => i.$emit("overlay-closed"))
          }), Be({ _: 2 }, [
            i.$slots["year-overlay-value"] ? {
              name: "item",
              fn: se(({ item: ae }) => [
                H(i.$slots, "year-overlay-value", {
                  text: ae.text,
                  value: ae.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : _("", !0)
        ], 64))
      ]);
    };
  }
}), bl = {
  key: 0,
  class: "dp__time_input"
}, $l = ["aria-label", "onKeydown", "onClick"], Dl = ["aria-label", "data-test", "onKeydown", "onClick"], Ml = ["aria-label", "onKeydown", "onClick"], _l = { key: 0 }, Tl = ["aria-label", "onKeydown"], Al = /* @__PURE__ */ Ue({
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    ...Qe
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setTimePickerElements: l, setTimePickerBackRef: c } = Je(), { defaults: k } = Ve(t), { transitionName: M, showTransition: O } = Ft(k.value.transitions), I = $t({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), F = W("AM"), C = W(null), u = W([]);
    Fe(() => {
      a("mounted");
    });
    const T = Y(() => (d) => !!(t.maxTime && t.maxTime[d] && t.maxTime[d] < t[d] + +t[`${d}Increment`])), U = Y(() => (d) => !!(t.minTime && t.minTime[d] && t.minTime[d] > t[d] - +t[`${d}Increment`])), V = (d, r) => Fn(Re(w(), d), r), J = (d, r) => ua(Re(w(), d), r), B = Y(
      () => ({
        dp__time_col: !0,
        dp__time_col_reg: !t.enableSeconds && t.is24,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), E = Y(() => {
      const d = [{ type: "hours" }, { type: "", separator: !0 }, { type: "minutes" }];
      return t.enableSeconds ? d.concat([{ type: "", separator: !0 }, { type: "seconds" }]) : d;
    }), N = Y(() => E.value.filter((d) => !d.separator)), K = Y(() => (d) => {
      if (d === "hours") {
        const r = Z(t.hours);
        return { text: r < 10 ? `0${r}` : `${r}`, value: r };
      }
      return { text: t[d] < 10 ? `0${t[d]}` : `${t[d]}`, value: t[d] };
    }), te = (d) => {
      const r = t.is24 ? 24 : 12, m = d === "hours" ? r : 60, h = +t[`${d}GridIncrement`], $ = d === "hours" && !t.is24 ? h : 0, X = [];
      for (let re = $; re < m; re += h)
        X.push({ value: re, text: re < 10 ? `0${re}` : `${re}` });
      return d === "hours" && !t.is24 && X.push({ value: 0, text: "12" }), Mr(X);
    }, le = (d, r) => {
      const m = t.minTime && t.minTime[r], h = t.maxTime && t.maxTime[r];
      return m && h ? d < m || d > h : m ? d < m : h ? d > h : !1;
    }, f = Y(() => (d) => te(d).flat().map((m) => m.value).filter((m) => le(m, d))), D = (d) => t[`no${d[0].toUpperCase() + d.slice(1)}Overlay`], L = (d) => {
      D(d) || (I[d] = !I[d], I[d] || a("overlay-closed"));
    }, x = (d) => d === "hours" ? Ke : d === "minutes" ? xe : dt, R = (d, r = !0) => {
      const m = r ? V : J;
      (r ? T.value(d) : U.value(d)) || a(
        `update:${d}`,
        x(d)(m({ [d]: +t[d] }, { [d]: +t[`${d}Increment`] }))
      );
    }, Z = (d) => t.is24 ? d : (d >= 12 ? F.value = "PM" : F.value = "AM", Sr(d)), ne = () => {
      F.value === "PM" ? (F.value = "AM", a("update:hours", t.hours - 12)) : (F.value = "PM", a("update:hours", t.hours + 12));
    }, A = (d) => {
      I[d] = !0;
    }, g = (d, r, m) => {
      if (d && t.arrowNavigation) {
        Array.isArray(u.value[r]) ? u.value[r][m] = d : u.value[r] = [d];
        const h = u.value.reduce(
          ($, X) => X.map((re, v) => [...$[v] || [], X[v]]),
          []
        );
        c(t.closeTimePickerBtn), C.value && (h[1] = h[1].concat(C.value)), l(h, t.order);
      }
    }, z = (d, r) => d === "hours" && !t.is24 ? a(`update:${d}`, F.value === "PM" ? r + 12 : r) : a(`update:${d}`, r);
    return n({ openChildCmp: A }), (d, r) => {
      var m;
      return d.disabled ? _("", !0) : (p(), P("div", bl, [
        (p(!0), P(ce, null, De(s(E), (h, $) => {
          var X, re, v;
          return p(), P("div", {
            key: $,
            class: ve(s(B))
          }, [
            h.separator ? (p(), P(ce, { key: 0 }, [
              We(" : ")
            ], 64)) : (p(), P(ce, { key: 1 }, [
              ee("div", {
                class: ve({
                  dp__inc_dec_button: !0,
                  dp__inc_dec_button_disabled: s(T)(h.type)
                }),
                role: "button",
                "data-test": "time-inc-btn",
                "aria-label": (X = s(k).ariaLabels) == null ? void 0 : X.incrementValue(h.type),
                tabindex: "0",
                onKeydown: [
                  ie((i) => R(h.type), ["enter"]),
                  ie((i) => R(h.type), ["space"])
                ],
                onClick: (i) => R(h.type),
                ref_for: !0,
                ref: (i) => g(i, $, 0)
              }, [
                d.$slots["arrow-up"] ? H(d.$slots, "arrow-up", { key: 0 }) : _("", !0),
                d.$slots["arrow-up"] ? _("", !0) : (p(), de(s(Hn), { key: 1 }))
              ], 42, $l),
              ee("div", {
                role: "button",
                "aria-label": (re = s(k).ariaLabels) == null ? void 0 : re.openTpOverlay(h.type),
                class: ve(D(h.type) ? "" : "dp__time_display"),
                tabindex: "0",
                "data-test": `${h.type}-toggle-overlay-btn`,
                onKeydown: [
                  ie((i) => L(h.type), ["enter"]),
                  ie((i) => L(h.type), ["space"])
                ],
                onClick: (i) => L(h.type),
                ref_for: !0,
                ref: (i) => g(i, $, 1)
              }, [
                d.$slots[h.type] ? H(d.$slots, h.type, {
                  key: 0,
                  text: s(K)(h.type).text,
                  value: s(K)(h.type).value
                }) : _("", !0),
                d.$slots[h.type] ? _("", !0) : (p(), P(ce, { key: 1 }, [
                  We(Se(s(K)(h.type).text), 1)
                ], 64))
              ], 42, Dl),
              ee("div", {
                class: ve({
                  dp__inc_dec_button: !0,
                  dp__inc_dec_button_disabled: s(U)(h.type)
                }),
                role: "button",
                "data-test": "time-dec-btn",
                "aria-label": (v = s(k).ariaLabels) == null ? void 0 : v.decrementValue(h.type),
                tabindex: "0",
                onKeydown: [
                  ie((i) => R(h.type, !1), ["enter"]),
                  ie((i) => R(h.type, !1), ["space"])
                ],
                onClick: (i) => R(h.type, !1),
                ref_for: !0,
                ref: (i) => g(i, $, 2)
              }, [
                d.$slots["arrow-down"] ? H(d.$slots, "arrow-down", { key: 0 }) : _("", !0),
                d.$slots["arrow-down"] ? _("", !0) : (p(), de(s(Wn), { key: 1 }))
              ], 42, Ml)
            ], 64))
          ], 2);
        }), 128)),
        d.is24 ? _("", !0) : (p(), P("div", _l, [
          d.$slots["am-pm-button"] ? H(d.$slots, "am-pm-button", {
            key: 0,
            toggle: ne,
            value: F.value
          }) : _("", !0),
          d.$slots["am-pm-button"] ? _("", !0) : (p(), P("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: C,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (m = s(k).ariaLabels) == null ? void 0 : m.amPmButton,
            tabindex: "0",
            onClick: ne,
            onKeydown: [
              ie(Ge(ne, ["prevent"]), ["enter"]),
              ie(Ge(ne, ["prevent"]), ["space"])
            ]
          }, Se(F.value), 41, Tl))
        ])),
        (p(!0), P(ce, null, De(s(N), (h, $) => (p(), de(mt, {
          key: $,
          name: s(M)(I[h.type]),
          css: s(O)
        }, {
          default: se(() => [
            I[h.type] ? (p(), de(bt, {
              key: 0,
              items: te(h.type),
              "disabled-values": s(k).filters.times[h.type].concat(s(f)(h.type)),
              "esc-close": d.escClose,
              "aria-labels": s(k).ariaLabels,
              "hide-navigation": d.hideNavigation,
              "onUpdate:modelValue": (X) => z(h.type, X),
              onSelected: (X) => L(h.type),
              onToggle: (X) => L(h.type),
              onResetFlow: r[0] || (r[0] = (X) => d.$emit("reset-flow")),
              type: h.type
            }, Be({
              "button-icon": se(() => [
                d.$slots["clock-icon"] ? H(d.$slots, "clock-icon", { key: 0 }) : _("", !0),
                d.$slots["clock-icon"] ? _("", !0) : (p(), de(s(Un), { key: 1 }))
              ]),
              _: 2
            }, [
              d.$slots[`${h.type}-overlay-value`] ? {
                name: "item",
                fn: se(({ item: X }) => [
                  H(d.$slots, `${h.type}-overlay-value`, {
                    text: X.text,
                    value: X.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "disabled-values", "esc-close", "aria-labels", "hide-navigation", "onUpdate:modelValue", "onSelected", "onToggle", "type"])) : _("", !0)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Sl = ["aria-label"], Cl = { class: "dp__overlay_container dp__container_flex" }, Pl = {
  key: 1,
  class: "dp__overlay_row"
}, Nl = ["aria-label"], Rl = /* @__PURE__ */ Ue({
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    internalModelValue: { type: [Date, Array], default: null },
    ...Qe
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMatrix: l, setTimePicker: c } = Je(), k = un(), { hideNavigationButtons: M, defaults: O } = Ve(t), { transitionName: I, showTransition: F } = Ft(O.value.transitions), C = W(null), u = W(null), T = W([]), U = W(null);
    Fe(() => {
      a("mount"), !t.timePicker && t.arrowNavigation ? l([Ce(C.value)], "time") : c(!0, t.timePicker);
    });
    const V = Y(() => t.range && t.modelAuto ? Gn(t.internalModelValue) : !0), J = W(!1), B = (R) => ({
      hours: Array.isArray(t.hours) ? t.hours[R] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[R] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[R] : t.seconds
    }), E = Y(() => {
      const R = [];
      if (t.range)
        for (let Z = 0; Z < 2; Z++)
          R.push(B(Z));
      else
        R.push(B(0));
      return R;
    }), N = (R, Z = !1, ne = "") => {
      Z || a("reset-flow"), J.value = R, t.arrowNavigation && (c(R), R || a("overlay-closed")), Dt(() => {
        ne !== "" && T.value[0] && T.value[0].openChildCmp(ne);
      });
    }, K = Y(() => ({
      dp__button: !0,
      dp__button_bottom: t.autoApply
    })), te = rt(k, "timePicker"), le = (R, Z, ne) => t.range ? Z === 0 ? [R, E.value[1][ne]] : [E.value[0][ne], R] : R, f = (R) => {
      a("update:hours", R);
    }, D = (R) => {
      a("update:minutes", R);
    }, L = (R) => {
      a("update:seconds", R);
    }, x = () => {
      U.value && t.arrowNavigation && U.value.focus({ preventScroll: !0 });
    };
    return n({ toggleTimePicker: N }), (R, Z) => {
      var ne;
      return p(), P("div", null, [
        R.timePicker ? _("", !0) : St((p(), P("div", {
          key: 0,
          class: ve(s(K)),
          role: "button",
          "aria-label": (ne = s(O).ariaLabels) == null ? void 0 : ne.openTimePicker,
          tabindex: "0",
          "data-test": "open-time-picker-btn",
          ref_key: "openTimePickerBtn",
          ref: C,
          onKeydown: [
            Z[0] || (Z[0] = ie((A) => N(!0), ["enter"])),
            Z[1] || (Z[1] = ie((A) => N(!0), ["space"]))
          ],
          onClick: Z[2] || (Z[2] = (A) => N(!0))
        }, [
          R.$slots["clock-icon"] ? H(R.$slots, "clock-icon", { key: 0 }) : _("", !0),
          R.$slots["clock-icon"] ? _("", !0) : (p(), de(s(Un), { key: 1 }))
        ], 42, Sl)), [
          [Ct, !s(M)("time")]
        ]),
        qe(mt, {
          name: s(I)(J.value),
          css: s(F)
        }, {
          default: se(() => {
            var A;
            return [
              J.value || R.timePicker ? (p(), P("div", {
                key: 0,
                class: "dp__overlay",
                ref_key: "overlayRef",
                ref: U,
                tabindex: "0"
              }, [
                ee("div", Cl, [
                  R.$slots["time-picker-overlay"] ? H(R.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: f,
                    setMinutes: D,
                    setSeconds: L
                  }) : _("", !0),
                  R.$slots["time-picker-overlay"] ? _("", !0) : (p(), P("div", Pl, [
                    (p(!0), P(ce, null, De(s(E), (g, z) => St((p(), de(Al, Ae({ key: z }, {
                      ...R.$props,
                      order: z,
                      hours: g.hours,
                      minutes: g.minutes,
                      seconds: g.seconds,
                      closeTimePickerBtn: u.value,
                      disabled: z === 0 ? R.fixedStart : R.fixedEnd
                    }, {
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: T,
                      "onUpdate:hours": (d) => f(le(d, z, "hours")),
                      "onUpdate:minutes": (d) => D(le(d, z, "minutes")),
                      "onUpdate:seconds": (d) => L(le(d, z, "seconds")),
                      onMounted: x,
                      onOverlayClosed: x
                    }), Be({ _: 2 }, [
                      De(s(te), (d, r) => ({
                        name: d,
                        fn: se((m) => [
                          H(R.$slots, d, Ye(Ze(m)))
                        ])
                      }))
                    ]), 1040, ["onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [Ct, z === 0 ? !0 : s(V)]
                    ])), 128))
                  ])),
                  R.timePicker ? _("", !0) : St((p(), P("div", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: u,
                    class: ve(s(K)),
                    role: "button",
                    "aria-label": (A = s(O).ariaLabels) == null ? void 0 : A.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      Z[3] || (Z[3] = ie((g) => N(!1), ["enter"])),
                      Z[4] || (Z[4] = ie((g) => N(!1), ["space"]))
                    ],
                    onClick: Z[5] || (Z[5] = (g) => N(!1))
                  }, [
                    R.$slots["calendar-icon"] ? H(R.$slots, "calendar-icon", { key: 0 }) : _("", !0),
                    R.$slots["calendar-icon"] ? _("", !0) : (p(), de(s(Et), { key: 1 }))
                  ], 42, Nl)), [
                    [Ct, !s(M)("time")]
                  ])
                ])
              ], 512)) : _("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), Il = (e, n) => {
  const { isDisabled: a, matchDate: t, getWeekFromDate: l } = Ve(n), c = W(null), k = W(w()), M = (r) => {
    !r.current && n.hideOffsetDates || (c.value = r.value);
  }, O = () => {
    c.value = null;
  }, I = (r) => Array.isArray(e.value) && n.range && e.value[0] && c.value ? r ? Oe(c.value, e.value[0]) : Pe(c.value, e.value[0]) : !0, F = (r, m) => {
    const h = () => e.value ? m ? e.value[0] || null : e.value[1] : null, $ = e.value && Array.isArray(e.value) ? h() : null;
    return pe(w(r.value), $);
  }, C = (r) => {
    const m = Array.isArray(e.value) ? e.value[0] : null;
    return r ? !Pe(c.value || null, m) : !0;
  }, u = (r, m = !0) => (n.range || n.weekPicker) && Array.isArray(e.value) ? n.hideOffsetDates && !r.current ? !1 : pe(w(r.value), e.value[m ? 0 : 1]) : n.range ? F(r, m) && C(m) || pe(r.value, Array.isArray(e.value) ? e.value[0] : null) && I(m) : !1, T = (r, m, h) => Array.isArray(e.value) && e.value[0] && e.value.length === 1 ? r ? !1 : h ? Oe(e.value[0], m.value) : Pe(e.value[0], m.value) : !1, U = (r) => !e.value || n.hideOffsetDates && !r.current ? !1 : n.range ? n.modelAuto && Array.isArray(e.value) ? pe(r.value, e.value[0] ? e.value[0] : k.value) : !1 : n.multiDates && Array.isArray(e.value) ? e.value.some((m) => pe(m, r.value)) : pe(r.value, e.value ? e.value : k.value), V = (r) => {
    if (n.autoRange || n.weekPicker) {
      if (c.value) {
        if (n.hideOffsetDates && !r.current)
          return !1;
        const m = ct(c.value, +n.autoRange), h = l(w(c.value));
        return n.weekPicker ? pe(h[1], w(r.value)) : pe(m, w(r.value));
      }
      return !1;
    }
    return !1;
  }, J = (r) => {
    if (n.autoRange || n.weekPicker) {
      if (c.value) {
        const m = ct(c.value, +n.autoRange);
        if (n.hideOffsetDates && !r.current)
          return !1;
        const h = l(w(c.value));
        return n.weekPicker ? Oe(r.value, h[0]) && Pe(r.value, h[1]) : Oe(r.value, c.value) && Pe(r.value, m);
      }
      return !1;
    }
    return !1;
  }, B = (r) => {
    if (n.autoRange || n.weekPicker) {
      if (c.value) {
        if (n.hideOffsetDates && !r.current)
          return !1;
        const m = l(w(c.value));
        return n.weekPicker ? pe(m[0], r.value) : pe(c.value, r.value);
      }
      return !1;
    }
    return !1;
  }, E = (r) => zn(e.value, c.value, r.value), N = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, K = () => n.modelAuto ? Gn(n.internalModelValue) : !0, te = (r) => {
    if (Array.isArray(e.value) && e.value.length || n.weekPicker)
      return !1;
    const m = n.range ? !u(r) && !u(r, !1) : !0;
    return !a(r.value) && !U(r) && !(!r.current && n.hideOffsetDates) && m;
  }, le = (r) => n.range ? n.modelAuto ? N() && U(r) : !1 : U(r), f = (r) => n.highlight ? t(r.value, n.highlight) : !1, D = (r) => a(r.value) && n.highlightDisabledDays === !1, L = (r) => n.highlightWeekDays && n.highlightWeekDays.includes(r.value.getDay()), x = (r) => (n.range || n.weekPicker) && (n.multiCalendars > 0 ? r.current : !0) && K() && !(!r.current && n.hideOffsetDates) && !U(r) ? E(r) : !1, R = (r) => ({
    dp__cell_offset: !r.current,
    dp__pointer: !n.disabled && !(!r.current && n.hideOffsetDates) && !a(r.value),
    dp__cell_disabled: a(r.value),
    dp__cell_highlight: !D(r) && (f(r) || L(r)) && !le(r),
    dp__cell_highlight_active: !D(r) && (f(r) || L(r)) && le(r),
    dp__today: !n.noToday && pe(r.value, k.value) && r.current
  }), Z = (r) => ({
    dp__active_date: le(r),
    dp__date_hover: te(r)
  }), ne = (r) => ({
    ...A(r),
    ...g(r),
    dp__range_between_week: x(r) && n.weekPicker
  }), A = (r) => ({
    dp__range_start: n.multiCalendars > 0 ? r.current && u(r) && K() : u(r) && K(),
    dp__range_end: n.multiCalendars > 0 ? r.current && u(r, !1) && K() : u(r, !1) && K(),
    dp__range_between: x(r) && !n.weekPicker,
    dp__date_hover_start: T(te(r), r, !0),
    dp__date_hover_end: T(te(r), r, !1)
  }), g = (r) => ({
    ...A(r),
    dp__cell_auto_range: J(r),
    dp__cell_auto_range_start: B(r),
    dp__cell_auto_range_end: V(r)
  }), z = (r) => n.range ? n.autoRange ? g(r) : n.modelAuto ? { ...Z(r), ...A(r) } : A(r) : n.weekPicker ? ne(r) : Z(r);
  return {
    setHoverDate: M,
    clearHoverDate: O,
    getDayClassData: (r) => ({
      ...R(r),
      ...z(r),
      [n.dayClass ? n.dayClass(r.value) : ""]: !0,
      [n.calendarCellClassName]: !!n.calendarCellClassName
    })
  };
}, Ol = ["id", "onKeydown"], Bl = {
  key: 0,
  class: "dp__sidebar_left"
}, Yl = {
  key: 1,
  class: "dp__preset_ranges"
}, Vl = ["onClick"], Ll = {
  key: 2,
  class: "dp__sidebar_right"
}, El = {
  key: 3,
  class: "dp__now_wrap"
}, Fl = /* @__PURE__ */ Ue({
  __name: "DatepickerMenu",
  props: {
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    ...Qe
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setMenuFocused: l, setShiftKey: c, control: k } = jn(), { getCalendarDays: M, defaults: O } = Ve(t), I = un(), F = W(null), C = $t({
      timePicker: !!(!t.enableTimePicker || t.timePicker || t.monthPicker),
      monthYearInput: !!t.timePicker,
      calendar: !1
    }), u = W([]), T = W([]), U = W(null), V = W(null), J = W(0), B = W(!1), E = W(0);
    Fe(() => {
      var G;
      B.value = !0, !((G = t.presetRanges) != null && G.length) && !I["left-sidebar"] && !I["right-sidebar"] && je();
      const y = Ce(V);
      if (y && !t.textInput && !t.inline && (l(!0), D()), y) {
        const we = (_e) => {
          !t.monthYearComponent && !t.timePickerComponent && !Object.keys(I).length && _e.preventDefault(), _e.stopImmediatePropagation(), _e.stopPropagation();
        };
        y.addEventListener("pointerdown", we), y.addEventListener("mousedown", we);
      }
      window.addEventListener("resize", je);
    }), sn(() => {
      window.removeEventListener("resize", je);
    });
    const { arrowRight: N, arrowLeft: K, arrowDown: te, arrowUp: le } = Je(), f = (y) => {
      y || y === 0 ? T.value[y].triggerTransition(
        ne.value(y),
        A.value(y)
      ) : T.value.forEach(
        (G, we) => G.triggerTransition(ne.value(we), A.value(we))
      );
    }, D = () => {
      const y = Ce(V);
      y && y.focus({ preventScroll: !0 });
    }, L = () => {
      var y;
      ((y = t.flow) == null ? void 0 : y.length) && E.value !== -1 && (E.value += 1, a("flow-step", E.value), b());
    }, x = () => {
      E.value = -1;
    }, {
      calendars: R,
      modelValue: Z,
      month: ne,
      year: A,
      time: g,
      updateTime: z,
      updateMonthYear: d,
      selectDate: r,
      getWeekNum: m,
      monthYearSelect: h,
      handleScroll: $,
      handleArrow: X,
      handleSwipe: re,
      getMarker: v,
      selectCurrentDate: i,
      presetDateRange: S
    } = Yr(t, a, L, f, E), { setHoverDate: fe, clearHoverDate: $e, getDayClassData: be } = Il(Z, t);
    ft(
      R,
      () => {
        t.openOnTop && setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    );
    const He = rt(I, "calendar"), Xe = rt(I, "action"), ae = rt(I, "timePicker"), oe = rt(I, "monthYear"), ke = Y(() => t.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), me = Y(() => Tr(t.yearRange)), vt = Y(() => Ar(t.locale, t.monthNameFormat)), je = () => {
      const y = Ce(F);
      y && (J.value = y.getBoundingClientRect().width);
    }, yt = Y(() => (y) => M(ne.value(y), A.value(y))), et = Y(
      () => O.value.multiCalendars > 0 && t.range ? [...Array(O.value.multiCalendars).keys()] : [0]
    ), ht = Y(
      () => (y) => y === 1
    ), Ut = Y(() => t.monthPicker || t.timePicker || t.yearPicker), Ht = Y(
      () => ({
        dp__flex_display: O.value.multiCalendars > 0
      })
    ), Mt = Y(() => ({
      dp__instance_calendar: O.value.multiCalendars > 0
    })), gt = Y(() => ({
      dp__menu_disabled: t.disabled,
      dp__menu_readonly: t.readonly
    })), Wt = Y(
      () => (y) => jt(yt, y)
    ), zt = Y(
      () => ({
        dp__menu: !0,
        dp__menu_index: !t.inline,
        dp__relative: t.inline,
        [t.menuClassName]: !!t.menuClassName
      })
    ), jt = (y, G) => y.value(G).map((we) => ({
      ...we,
      days: we.days.map((_e) => (_e.marker = v(_e), _e.classData = be(_e), _e))
    })), _t = (y) => {
      y.stopPropagation(), y.stopImmediatePropagation();
    }, hn = () => {
      t.escClose && a("close-picker");
    }, gn = (y, G = !1) => {
      r(y, G), t.spaceConfirm && a("select-date");
    }, Tt = (y) => {
      var G;
      (G = t.flow) != null && G.length && (C[y] = !0, Object.keys(C).filter((we) => !C[we]).length || b());
    }, o = (y, G, we, _e, ...Ee) => {
      if (t.flow[E.value] === y) {
        const q = _e ? G.value[0] : G.value;
        q && q[we](...Ee);
      }
    }, b = () => {
      o("month", u, "toggleMonthPicker", !0, !0), o("year", u, "toggleYearPicker", !0, !0), o("calendar", U, "toggleTimePicker", !1, !1, !0), o("time", U, "toggleTimePicker", !1, !0, !0);
      const y = t.flow[E.value];
      (y === "hours" || y === "minutes" || y === "seconds") && o(y, U, "toggleTimePicker", !1, !0, !0, y);
    }, j = (y) => {
      if (t.arrowNavigation) {
        if (y === "up")
          return le();
        if (y === "down")
          return te();
        if (y === "left")
          return K();
        if (y === "right")
          return N();
      } else
        y === "left" || y === "up" ? X("left", 0, y === "up") : X("right", 0, y === "down");
    }, Q = (y) => {
      c(y.shiftKey), !t.disableMonthYearSelect && y.code === "Tab" && y.target.classList.contains("dp__menu") && k.value.shiftKeyInMenu && (y.preventDefault(), y.stopImmediatePropagation(), a("close-picker"));
    };
    return n({
      updateMonthYear: d
    }), (y, G) => {
      var we;
      return p(), de(mt, {
        appear: "",
        name: (we = s(O).transitions) == null ? void 0 : we.menuAppear,
        mode: "out-in",
        css: !!y.transitions
      }, {
        default: se(() => {
          var _e, Ee;
          return [
            ee("div", {
              id: y.uid ? `dp-menu-${y.uid}` : void 0,
              tabindex: "0",
              ref_key: "dpMenuRef",
              ref: V,
              role: "dialog",
              class: ve(s(zt)),
              onMouseleave: G[12] || (G[12] = (...q) => s($e) && s($e)(...q)),
              onClick: _t,
              onKeydown: [
                ie(hn, ["esc"]),
                G[13] || (G[13] = ie(Ge((q) => j("left"), ["prevent"]), ["left"])),
                G[14] || (G[14] = ie(Ge((q) => j("up"), ["prevent"]), ["up"])),
                G[15] || (G[15] = ie(Ge((q) => j("down"), ["prevent"]), ["down"])),
                G[16] || (G[16] = ie(Ge((q) => j("right"), ["prevent"]), ["right"])),
                Q
              ]
            }, [
              (y.disabled || y.readonly) && y.inline ? (p(), P("div", {
                key: 0,
                class: ve(s(gt))
              }, null, 2)) : _("", !0),
              !y.inline && !y.teleportCenter ? (p(), P("div", {
                key: 1,
                class: ve(s(ke))
              }, null, 2)) : _("", !0),
              ee("div", {
                class: ve({
                  dp__menu_content_wrapper: ((_e = y.presetRanges) == null ? void 0 : _e.length) || !!y.$slots["left-sidebar"] || !!y.$slots["right-sidebar"]
                })
              }, [
                y.$slots["left-sidebar"] ? (p(), P("div", Bl, [
                  H(y.$slots, "left-sidebar")
                ])) : _("", !0),
                (Ee = y.presetRanges) != null && Ee.length ? (p(), P("div", Yl, [
                  (p(!0), P(ce, null, De(y.presetRanges, (q, st) => (p(), P("div", {
                    key: st,
                    style: ut(q.style || {}),
                    class: "dp__preset_range",
                    onClick: (ue) => s(S)(q.range, !!q.slot)
                  }, [
                    q.slot ? H(y.$slots, q.slot, {
                      key: 0,
                      presetDateRange: s(S),
                      label: q.label,
                      range: q.range
                    }) : (p(), P(ce, { key: 1 }, [
                      We(Se(q.label), 1)
                    ], 64))
                  ], 12, Vl))), 128))
                ])) : _("", !0),
                ee("div", {
                  class: "dp__instance_calendar",
                  ref_key: "calendarWrapperRef",
                  ref: F,
                  role: "document"
                }, [
                  ee("div", {
                    class: ve(s(Ht))
                  }, [
                    (p(!0), P(ce, null, De(s(et), (q, st) => (p(), P("div", {
                      key: q,
                      class: ve(s(Mt))
                    }, [
                      !y.disableMonthYearSelect && !y.timePicker ? (p(), de(Pt(y.monthYearComponent ? y.monthYearComponent : wl), Ae({
                        key: 0,
                        ref_for: !0,
                        ref: (ue) => {
                          ue && (u.value[st] = ue);
                        },
                        months: s(vt),
                        years: s(me),
                        month: s(ne)(q),
                        year: s(A)(q),
                        instance: q,
                        "internal-model-value": e.internalModelValue
                      }, y.$props, {
                        onMount: G[0] || (G[0] = (ue) => Tt("monthYearInput")),
                        onResetFlow: x,
                        onUpdateMonthYear: (ue) => s(d)(q, ue),
                        onMonthYearSelect: s(h),
                        onOverlayClosed: D
                      }), Be({ _: 2 }, [
                        De(s(oe), (ue, Xn) => ({
                          name: ue,
                          fn: se((Kt) => [
                            H(y.$slots, ue, Ye(Ze(Kt)))
                          ])
                        }))
                      ]), 1040, ["months", "years", "month", "year", "instance", "internal-model-value", "onUpdateMonthYear", "onMonthYearSelect"])) : _("", !0),
                      qe(sl, Ae({
                        ref_for: !0,
                        ref: (ue) => {
                          ue && (T.value[st] = ue);
                        },
                        "specific-mode": s(Ut),
                        "get-week-num": s(m),
                        instance: q,
                        "mapped-dates": s(Wt)(q),
                        month: s(ne)(q),
                        year: s(A)(q)
                      }, y.$props, {
                        "flow-step": E.value,
                        "onUpdate:flow-step": G[1] || (G[1] = (ue) => E.value = ue),
                        onSelectDate: (ue) => s(r)(ue, !s(ht)(q)),
                        onHandleSpace: (ue) => gn(ue, !s(ht)(q)),
                        onSetHoverDate: G[2] || (G[2] = (ue) => s(fe)(ue)),
                        onHandleScroll: (ue) => s($)(ue, q),
                        onHandleSwipe: (ue) => s(re)(ue, q),
                        onMount: G[3] || (G[3] = (ue) => Tt("calendar")),
                        onResetFlow: x
                      }), Be({ _: 2 }, [
                        De(s(He), (ue, Xn) => ({
                          name: ue,
                          fn: se((Kt) => [
                            H(y.$slots, ue, Ye(Ze({ ...Kt })))
                          ])
                        }))
                      ]), 1040, ["specific-mode", "get-week-num", "instance", "mapped-dates", "month", "year", "flow-step", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
                    ], 2))), 128))
                  ], 2),
                  ee("div", null, [
                    y.$slots["time-picker"] ? H(y.$slots, "time-picker", Ye(Ae({ key: 0 }, { time: s(g), updateTime: s(z) }))) : (p(), P(ce, { key: 1 }, [
                      y.enableTimePicker && !y.monthPicker && !y.weekPicker ? (p(), de(Pt(y.timePickerComponent ? y.timePickerComponent : Rl), Ae({
                        key: 0,
                        ref_key: "timePickerRef",
                        ref: U,
                        hours: s(g).hours,
                        minutes: s(g).minutes,
                        seconds: s(g).seconds,
                        "internal-model-value": e.internalModelValue
                      }, y.$props, {
                        onMount: G[4] || (G[4] = (q) => Tt("timePicker")),
                        "onUpdate:hours": G[5] || (G[5] = (q) => s(z)(q)),
                        "onUpdate:minutes": G[6] || (G[6] = (q) => s(z)(q, !1)),
                        "onUpdate:seconds": G[7] || (G[7] = (q) => s(z)(q, !1, !0)),
                        onResetFlow: x,
                        onOverlayClosed: D
                      }), Be({ _: 2 }, [
                        De(s(ae), (q, st) => ({
                          name: q,
                          fn: se((ue) => [
                            H(y.$slots, q, Ye(Ze(ue)))
                          ])
                        }))
                      ]), 1040, ["hours", "minutes", "seconds", "internal-model-value"])) : _("", !0)
                    ], 64))
                  ])
                ], 512),
                y.$slots["right-sidebar"] ? (p(), P("div", Ll, [
                  H(y.$slots, "right-sidebar")
                ])) : _("", !0),
                y.showNowButton ? (p(), P("div", El, [
                  y.$slots["now-button"] ? H(y.$slots, "now-button", {
                    key: 0,
                    selectCurrentDate: s(i)
                  }) : _("", !0),
                  y.$slots["now-button"] ? _("", !0) : (p(), P("button", {
                    key: 1,
                    type: "button",
                    role: "button",
                    class: "dp__now_button",
                    onClick: G[8] || (G[8] = (...q) => s(i) && s(i)(...q))
                  }, Se(y.nowButtonLabel), 1))
                ])) : _("", !0)
              ], 2),
              !y.autoApply || y.keepActionRow ? (p(), de(Pt(y.actionRowComponent ? y.actionRowComponent : qr), Ae({
                key: 2,
                "menu-mount": B.value,
                "calendar-width": J.value,
                "internal-model-value": e.internalModelValue
              }, y.$props, {
                onClosePicker: G[9] || (G[9] = (q) => y.$emit("close-picker")),
                onSelectDate: G[10] || (G[10] = (q) => y.$emit("select-date")),
                onInvalidSelect: G[11] || (G[11] = (q) => y.$emit("invalid-select"))
              }), Be({ _: 2 }, [
                De(s(Xe), (q, st) => ({
                  name: q,
                  fn: se((ue) => [
                    H(y.$slots, q, Ye(Ze({ ...ue })))
                  ])
                }))
              ]), 1040, ["menu-mount", "calendar-width", "internal-model-value"])) : _("", !0)
            ], 42, Ol)
          ];
        }),
        _: 3
      }, 8, ["name", "css"]);
    };
  }
}), Ul = typeof window < "u" ? window : void 0, nn = () => {
}, Hl = (e) => Jn() ? (Qn(e), !0) : !1, Wl = (e, n, a, t) => {
  if (!e)
    return nn;
  let l = nn;
  const c = ft(
    () => s(e),
    (M) => {
      l(), M && (M.addEventListener(n, a, t), l = () => {
        M.removeEventListener(n, a, t), l = nn;
      });
    },
    { immediate: !0, flush: "post" }
  ), k = () => {
    c(), l();
  };
  return Hl(k), k;
}, zl = (e, n, a, t = {}) => {
  const { window: l = Ul, event: c = "pointerdown" } = t;
  return l ? Wl(l, c, (M) => {
    const O = Ce(e), I = Ce(n);
    !O || !I || O === M.target || M.composedPath().includes(O) || M.composedPath().includes(I) || a(M);
  }, { passive: !0 }) : void 0;
}, jl = /* @__PURE__ */ Ue({
  __name: "VueDatePicker",
  props: {
    ...Qe
  },
  emits: [
    "update:model-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, l = un(), c = W(!1), k = an(t, "modelValue"), M = an(t, "timezone"), O = W(null), I = W(null), F = W(!1), { setMenuFocused: C, setShiftKey: u } = jn(), { clearArrowNav: T } = Je(), { validateDate: U, isValidTime: V, defaults: J } = Ve(t);
    Fe(() => {
      L(t.modelValue), t.inline || (window.addEventListener("scroll", g), window.addEventListener("resize", z)), t.inline && (c.value = !0);
    }), sn(() => {
      t.inline || (window.removeEventListener("scroll", g), window.removeEventListener("resize", z));
    });
    const B = rt(l, "all", t.presetRanges), E = rt(l, "input");
    ft(
      [k, M],
      () => {
        L(k.value);
      },
      { deep: !0 }
    );
    const { openOnTop: N, menuPosition: K, setMenuPosition: te, setInitialPosition: le } = Er(
      O,
      I,
      a,
      t
    ), {
      inputValue: f,
      internalModelValue: D,
      parseExternalModelValue: L,
      emitModelValue: x,
      formatInputValue: R,
      checkBeforeEmit: Z
    } = Vr(a, t, F), ne = Y(
      () => ({
        dp__main: !0,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: t.inline,
        dp__flex_display_with_input: t.inlineWithInput
      })
    ), A = Y(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), g = () => {
      c.value && (t.closeOnScroll ? v() : t.autoPosition && te());
    }, z = () => {
      c.value && te();
    }, d = () => {
      !t.disabled && !t.readonly && (le(), c.value = !0, Dt().then(() => {
        te(), c.value && a("open");
      }), c.value || re(), L(t.modelValue));
    }, r = () => {
      f.value = "", re(), a("update:model-value", null), a("cleared"), v();
    }, m = () => {
      const oe = D.value;
      return !oe || !Array.isArray(oe) && U(oe) ? !0 : Array.isArray(oe) ? oe.length === 2 && U(oe[0]) && U(oe[1]) ? !0 : U(oe[0]) : !1;
    }, h = () => {
      Z() && m() ? (x(), v()) : a("invalid-select", D.value);
    }, $ = (oe) => {
      x(), t.closeOnAutoApply && !oe && v();
    }, X = (oe = !1) => {
      t.autoApply && V(D.value) && m() && (t.range && Array.isArray(D.value) ? (t.partialRange || D.value.length === 2) && $(oe) : $(oe));
    }, re = () => {
      t.textInput || (D.value = null);
    }, v = () => {
      t.inline || (c.value && (c.value = !1, C(!1), u(!1), T(), a("closed"), le(), f.value && L(k.value)), re(), I.value && I.value.focusInput());
    }, i = (oe, ke) => {
      if (!oe) {
        D.value = null;
        return;
      }
      D.value = oe, ke && (h(), a("text-submit"));
    }, S = () => {
      t.autoApply && V(D.value) && x();
    }, fe = () => c.value ? v() : d(), $e = (oe) => {
      D.value = oe;
    }, be = Y(() => t.textInput && J.value.textInputOptions.format), He = () => {
      be.value && (F.value = !0, R()), a("focus");
    }, Xe = () => {
      be.value && (F.value = !1, R()), a("blur");
    }, ae = (oe) => {
      O.value && O.value.updateMonthYear(0, {
        month: Nn(oe.month),
        year: Nn(oe.year)
      });
    };
    return zl(
      O,
      I,
      t.onClickOutside ? () => t.onClickOutside(m) : v
    ), n({
      closeMenu: v,
      selectDate: h,
      clearValue: r,
      openMenu: d,
      onScroll: g,
      formatInputValue: R,
      updateInternalModelValue: $e,
      setMonthYear: ae
    }), (oe, ke) => (p(), P("div", {
      class: ve(s(ne))
    }, [
      qe(xr, Ae({
        ref_key: "inputRef",
        ref: I,
        "is-menu-open": c.value,
        "input-value": s(f),
        "onUpdate:input-value": ke[0] || (ke[0] = (me) => nt(f) ? f.value = me : null)
      }, oe.$props, {
        onClear: r,
        onOpen: d,
        onSetInputDate: i,
        onSetEmptyDate: s(x),
        onSelectDate: h,
        onToggle: fe,
        onClose: v,
        onFocus: He,
        onBlur: Xe
      }), Be({ _: 2 }, [
        De(s(E), (me, vt) => ({
          name: me,
          fn: se((je) => [
            H(oe.$slots, me, Ye(Ze(je)))
          ])
        }))
      ]), 1040, ["is-menu-open", "input-value", "onSetEmptyDate"]),
      c.value ? (p(), de(ea, {
        key: 0,
        to: oe.teleport,
        disabled: oe.inline
      }, [
        c.value ? (p(), de(Fl, Ae({
          key: 0,
          ref_key: "dpMenuRef",
          ref: O,
          class: s(A),
          style: s(K),
          "open-on-top": s(N)
        }, oe.$props, {
          "internal-model-value": s(D),
          "onUpdate:internal-model-value": ke[1] || (ke[1] = (me) => nt(D) ? D.value = me : null),
          onClosePicker: v,
          onSelectDate: h,
          onAutoApply: X,
          onTimeUpdate: S,
          onFlowStep: ke[2] || (ke[2] = (me) => oe.$emit("flow-step", me)),
          onUpdateMonthYear: ke[3] || (ke[3] = (me) => oe.$emit("update-month-year", me)),
          onInvalidSelect: ke[4] || (ke[4] = (me) => oe.$emit("invalid-select", s(D))),
          onRecalculatePosition: s(te)
        }), Be({ _: 2 }, [
          De(s(B), (me, vt) => ({
            name: me,
            fn: se((je) => [
              H(oe.$slots, me, Ye(Ze({ ...je })))
            ])
          }))
        ]), 1040, ["class", "style", "open-on-top", "internal-model-value", "onRecalculatePosition"])) : _("", !0)
      ], 8, ["to", "disabled"])) : _("", !0)
    ], 2));
  }
}), Zn = /* @__PURE__ */ (() => {
  const e = jl;
  return e.install = (n) => {
    n.component("Vue3DatePicker", e);
  }, e;
})(), Kl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Zn
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(Kl).forEach(([e, n]) => {
  e !== "default" && (Zn[e] = n);
});
export {
  Zn as default
};
